@page "/"
@inject NavigationManager NavManager
@using AcornSat.Core
@using Blazorise
@using Blazorise.Components
@using Blazorise.Charts
@using System.IO;
@using System.Globalization
@using Darnton.Blazor.DeviceInterop.Geolocation
@using static AcornSat.Core.Enums
@using GeoCoordinatePortable;
@using Microsoft.AspNetCore.WebUtilities

<PageTitle>Index</PageTitle>

 @*<h1><a href="http://www.bom.gov.au/climate/data/acorn-sat/" target="_blank">ACORN-SAT</a></h1>*@
<Row>
    @if (SelectedLocation != null)
    {
        <Column ColumnSize="ColumnSize.Is2">
            <Alert Color="Color.Primary" Visible="true">
                <FieldBody>
                    @SelectedLocation.Name
                </FieldBody>
                <br />
                <FieldBody>
                    @Math.Round(SelectedLocation.Coordinates.Latitude, 1)°, @Math.Round(SelectedLocation.Coordinates.Longitude, 1)°, @Math.Round(SelectedLocation.Coordinates.Elevation, 1) m
                </FieldBody>
                <br />
                <FieldBody>
                    Station(s): @string.Join(", ", SelectedLocation.Sites)
                </FieldBody>
                <br />
                <FieldBody>
                    Dataset: @SelectedDataSetDefinition.Name
                </FieldBody>
            </Alert>
        </Column>
    }
    <Column ColumnSize="ColumnSize.Is1">
        <Field>
            <Button Color="Color.Primary" Clicked="@ShowSelectLocationModal">Change Location</Button>
        </Field>
    </Column>
    <Column ColumnSize="ColumnSize.Is1">
        <Field>
            <Button Color="Color.Primary" Clicked="@ShowOptionsModal">Options</Button>
        </Field>
        <Field>
            <Button Color="Color.Primary" Clicked="@ShowFilterModal">Filter</Button>
        </Field>
   </Column>
</Row>

<Modal @ref="selectLocationModal">
    <ModalContent>
        <ModalHeader Background="Background.Light">
            <ModalTitle>Select Location</ModalTitle>
            <CloseButton />
        </ModalHeader>
        <ModalBody>
            @if (SelectedLocation != null)
            {
                <Field>
                    Current Location: @SelectedLocation.Name
                </Field>
            }
            <Field>
                <Button Clicked="@OnUseCurrentLocation" Color="Color.Primary">Use Your Location</Button>
            </Field>
            <Field> 
            </Field>
            <Field>
                <FieldLabel>Select a location from the list</FieldLabel>
                <SelectList
                    TItem="Location"
                    TValue="Guid"
                    Data="@Locations"
                    TextField="@((item)=>item.Name)"
                    ValueField="@((item)=>item.Id)"
                    SelectedValueChanged="@SelectedLocationChanged"
                    DefaultItemText="Select Location"
                    Style="width: 100%"
                    />
           </Field>
            @if (SelectedLocation != null)
            {
                <Field>
                    <FieldLabel>Select a nearby location</FieldLabel>
                    <Alert Color="Color.Secondary" Visible="true">
                        <Repeater Items="@SelectedLocation.NearbyLocations" >
                            <div>
                                <Blazorise.Link Title="@context.LocationName" To="#" Clicked="@(()=>OnNearbyLocationClicked(context.LocationId))">@context.LocationName</Blazorise.Link>
                                <span style="color: #888">
                                    @context.Distance km
                                    @context.CompassRoseDirection 
                                    <span style="display: inline-block; transform: rotate(@($"{context.BearingDegrees}deg"))">⭡</span>
                                </span>
                            </div>
                        </Repeater>
                    </Alert>
                </Field>
            }
        </ModalBody>
    </ModalContent>
</Modal>

 <Modal @ref="optionsModal">
    <ModalContent>
        <ModalHeader Background="Background.Light">
            <ModalTitle>Options</ModalTitle>
            <CloseButton />
        </ModalHeader>
        <ModalBody>
            <Alert Color="Color.Success" Visible="true">
                Chart Type
                <RadioGroup TValue="ChartType" CheckedValue="@SelectedChartType" CheckedValueChanged="@OnSelectedChartTypeValueChanged" Orientation="Orientation.Vertical">
                    <Radio TValue="ChartType" Value="ChartType.Line">Line chart</Radio>
                    <Radio TValue="ChartType" Value="ChartType.Bar">Bar chart - relative to average</Radio>
                </RadioGroup>
            </Alert>
           <Alert Color="Color.Secondary" Visible="true">
                Data Set
                <Check TValue="bool" Checked="@Unadjusted" CheckedChanged="@OnUnadjustedChanged" Disabled="@UnadjustedDisabled">Unadjusted</Check>
                <Check TValue="bool" Checked="@Adjusted" CheckedChanged="@OnAdjustedChanged"  Disabled="@AdjustedDisabled">Adjusted</Check>
                <Check TValue="bool" Checked="@Difference" CheckedChanged="@OnDifferenceChanged"  Disabled="@DifferenceDisabled">Difference</Check>
            </Alert>
            <Alert Color="Color.Primary" Visible="true">
                Temperatures
                <Check TValue="bool" Checked="@Maximums" CheckedChanged="@OnMaximumsChanged">Maximums</Check>
                <Check TValue="bool" Checked="@Minimums" CheckedChanged="@OnMinimumsChanged">Minimums</Check>
            </Alert>
            <Alert Color="Color.Info" Visible="true">
                Simple Moving Average<br/>
                <Select TValue="int" SelectedValue="@SelectedPeriod" SelectedValueChanged="@OnSelectedPeriodChanged">
                    <SelectItem Value="0">None</SelectItem>
                    <SelectItem Value="3">3 years</SelectItem>
                    <SelectItem Value="5">5 years</SelectItem>
                    <SelectItem Value="7">7 years</SelectItem>
                    <SelectItem Value="10">10 years</SelectItem>
                </Select>
                <Check TValue="bool" Checked="@SoloSma" CheckedChanged="@OnSoloSmaChanged">Solo</Check>
            </Alert>
            <Alert Color="Color.Danger" Visible="true">
                Day grouping<br/>
                <Select TValue="short" SelectedValue="@SelectedDayGrouping" SelectedValueChanged="@OnSelectingDayGroupingChanged">
                    <SelectItem Value="5">Groups of 5 days (73 groups)</SelectItem>
                    <SelectItem Value="7">Groups of 7 days (52 groups)</SelectItem>
                    <SelectItem Value="13">Groups of 13 days (28 groups)</SelectItem>
                    <SelectItem Value="14">Groups of 14 days (26 groups)</SelectItem>
                    <SelectItem Value="26">Groups of 26 days (14 groups)</SelectItem>
                    <SelectItem Value="28">Groups of 28 days (13 groups)</SelectItem>
                    <SelectItem Value="73">Groups of 73 days (5 groups)</SelectItem>
                    <SelectItem Value="91">Groups of 91 days (4 groups)</SelectItem>
                    <SelectItem Value="182">Groups of 182 days (2 groups)</SelectItem>
                </Select>
                Threshold required to form a valid group (% percentage)<br/>
                <TextEdit Text="@DayGroupThresholdText" TextChanged="@OnDayGroupThresholdTextChanged" MaskType="MaskType.RegEx" EditMask="^[1-9][0-9]?$|^100$" MaxLength="3" />
                <Button Color="Color.Primary" Clicked="@ApplyYearlyAverageParameters">Apply</Button>
            </Alert>
        </ModalBody>
    </ModalContent>
</Modal>

 <Modal @ref="filterModal">
    <ModalContent>
        <ModalHeader Background="Background.Light">
            <ModalTitle>Filter</ModalTitle>
            <CloseButton />
        </ModalHeader>
        <ModalBody>
            <Field>
            Selected year(s)
            <Autocomplete TItem="short"
                    TValue="short"
                    Data="@DatasetYears"
                    TextField="@((item) => item.ToString())"
                    ValueField="@((item) => item)"
                    Multiple
                    SelectedValuesChanged="@OnSelectedYearsChanged"
                    SelectedValues="@SelectedYears"
                    SelectedTexts="@SelectedYearsText">
                <NotFoundContent>@context was not found</NotFoundContent>
            </Autocomplete>
            </Field>
    
        @if (SelectedResolution == DataResolution.Yearly)
        {
            <Field>        
                Start Year <Validation Validator="ValidateYear"><TextEdit Text="@StartYear" MaskType="MaskType.RegEx" EditMask="^[\d]*$" MaxLength="4" TextChanged="OnStartYearTextChanged" /></Validation>
            </Field>
            <Field>
                End Year <Validation Validator="ValidateYear"><TextEdit Text="@EndYear" MaskType="MaskType.RegEx" EditMask="^[\d]*$" MaxLength="4" TextChanged="OnEndYearTextChanged" /></Validation>
            </Field>

        }
        @if (SelectedResolution != DataResolution.Yearly)
        {
            <Field>
            Resolution
            <Select TValue="DataResolution" SelectedValue="@SelectedResolution" SelectedValueChanged="@OnSelectedResolutionChanged">
                <SelectItem Value="@(DataResolution.Yearly)">Yearly</SelectItem>
                <SelectItem Value="@(DataResolution.Monthly)">Monthly</SelectItem>
                <SelectItem Value="@(DataResolution.Weekly)">Weekly</SelectItem>
                <SelectItem Value="@(DataResolution.Daily)">Daily</SelectItem>
            </Select>
            </Field>
                <Field>
            Selected Station
            <SelectList
                TItem="string"
                TValue="string"
                Data="@StationsWithData"
                TextField="@((item)=>item)"
                ValueField="@((item)=>item)"
                SelectedValueChanged="@SelectedStationChanged"
                Style="width: 100%"
                />
                </Field>
        }
        </ModalBody>
    </ModalContent>
</Modal>

<Map @ref="map" MapOptions="mapOptions"></Map>

<style>
    #mapId {
        height: 15%;
        width: 20%;
        position: absolute;
        top: 10px;
        right: 10px;
    }
</style>

@*<Button Clicked="@(async () => await ButtonClicked())">Redraw</Button>*@
<div style="width: 85%; border: 0.5px dotted; padding: 10px; position: absolute; bottom: 5px;">
    <Chart @ref="chart" TItem="float?" Clicked="@OnLineChartClicked" Type="ChartType.Bar" />
</div>

@code{
    async Task  OnNearbyLocationClicked(Guid guid)
    {
        await SelectedLocationChanged(guid);
    }

    float SelectedDayGroupThreshold { get; set; } = .7f;
    string DayGroupThresholdText { get; set; }
    short SelectedDayGrouping { get; set; } = 14;
    short SelectingDayGrouping { get; set; }

    async Task OnSelectingDayGroupingChanged(short value)
    {
        SelectingDayGrouping = value;
    }

    async Task OnDayGroupThresholdTextChanged(string value)
    {
        DayGroupThresholdText = value;
    }

    async Task ApplyYearlyAverageParameters()
    {
        SelectedDayGroupThreshold = float.Parse(DayGroupThresholdText) / 100;
        SelectedDayGrouping = SelectingDayGrouping == 0 ? SelectedDayGrouping : SelectingDayGrouping;
        await BuildLocationDataSets();
    }

    private Modal selectLocationModal;
    private Task ShowSelectLocationModal()
    {
        //DayGroupThresholdText = (SelectedDayGroupThreshold * 100).ToString();
        return selectLocationModal.Show();

    }
    private Task HideSelectLocationModal()
    {
        return selectLocationModal.Hide();
    }

    private Modal optionsModal;
    private Task ShowOptionsModal()
    {
        DayGroupThresholdText = (SelectedDayGroupThreshold * 100).ToString();
        return optionsModal.Show();

    }
    private Task HideOptionsModal()
    {
        return optionsModal.Hide();
    }

    private Modal filterModal;
    private Task ShowFilterModal()
    {
        return filterModal.Show();
    }
    private Task HideFilterModal()
    {
        return filterModal.Hide();
    }


    ChartType SelectedChartType { get; set; }
    async Task OnSelectedChartTypeValueChanged(ChartType value)
    {
        SelectedChartType = value;
        await BuildLocationDataSets();
    }

    [Inject] 
    public IGeolocationService GeolocationService { get; set; }

    async Task OnUseCurrentLocation()
    {
        var currentPositionResult = await GeolocationService.GetCurrentPosition();
        var lat = currentPositionResult.Position.Coords.Latitude;
        var lng = currentPositionResult.Position.Coords.Longitude;
        var alt = currentPositionResult.Position.Coords.Altitude;
        var geoCoord = alt == null ? new GeoCoordinate(lat, lng) :
                                     new GeoCoordinate(lat, lng, alt.Value);

        var distances = Location.GetDistances(geoCoord, Locations);
        var closestLocation = distances.OrderBy(x => x.Distance).First();

        await SelectedLocationChanged(closestLocation.LocationId);
    }

    List<string> SelectedYearsText = new();
    List<short> DatasetYears { get; set; }
    List<short> SelectedYears;

    async Task OnSelectedYearsChanged(List<short> values)
    {
        if (!SelectedYears.Any() && values.Count == 0)
        {
            SelectedResolution = DataResolution.Yearly;
            await InvokeAsync(StateHasChanged);
            await BuildLocationDataSets();
            return;
        }

        var validValues = new List<short>();
        foreach (var value in values)
        {
            if (DatasetYears.Any(x => x == value))
            {
                validValues.Add(value);
            }
        }
        SelectedYears = validValues;

        if (SelectedResolution == DataResolution.Yearly)
        {
            SelectedResolution = DataResolution.Monthly;
        }

        await InvokeAsync(StateHasChanged);
        await BuildLocationDataSets();
    }

    List<string> StationsWithData { get; set; }

    string SelectedStation { get; set; }
    async Task SelectedStationChanged(string value)
    {
        SelectedStation = value;
        await BuildLocationDataSets();
    }

    DataResolution SelectedResolution { get; set; }
    async Task OnSelectedResolutionChanged(DataResolution value)
    {
        SelectedResolution = value;
        if (SelectedResolution == DataResolution.Yearly)
        {
            SelectedYearsText = new();
            SelectedYears = new List<short>();
        }
        await BuildLocationDataSets();
    }

    int SelectedPeriod;
    async Task OnSelectedPeriodChanged(int value)
    {
        SelectedPeriod = value;
        await HandleRedraw();
    }

    bool SoloSma;
    async Task OnSoloSmaChanged(bool value)
    {
        SoloSma = value;
        await HandleRedraw();
    }

    bool Adjusted = true;
    async Task OnAdjustedChanged(bool value)
    {
        Adjusted = value;
        await HandleRedraw();
    }

    bool Unadjusted;
    async Task OnUnadjustedChanged(bool value)
    {
        Unadjusted = value;
        await HandleRedraw();
    }

    bool Difference = false;
    async Task OnDifferenceChanged(bool value)
    {
        Difference = value;
        await HandleRedraw();
    }

    bool UnadjustedDisabled, AdjustedDisabled, DifferenceDisabled;

    bool Maximums = true;
    async Task OnMaximumsChanged(bool value)
    {
        Maximums = value;
        await HandleRedraw();
    }

    bool Minimums;
    async Task OnMinimumsChanged(bool value)
    {
        Minimums = value;
        await HandleRedraw();
    }

    string StartYear { get; set; }
    string EndYear { get; set; }

    short StartYearOfChart { get; set; }

    Guid SelectedLocationId { get; set; }
    Location SelectedLocation { get; set; }
    DataSetDefinition SelectedDataSetDefinition { get; set; }

    [Inject]
    public IDataService DataService { get; set; }

    List<DataSet> Datasets { get; set; }
    IEnumerable<DataSetDefinition> DataSetDefinitions;
    IEnumerable<Location> Locations;
    List<Marker> MapMarkers;
    ColourServer colours = new ColourServer();

    async Task CreateMapMarkers()
    {
        MapMarkers = new List<Marker>();
        foreach (var location in Locations)
        {
            var marker = await MarkerFactory.Create(new LatLng(location.Coordinates.Latitude, location.Coordinates.Longitude, location.Coordinates.Elevation));
            await marker.BindTooltip(location.Name);
            await marker.OnClick(async (MouseEvent mouseEvent) => await HandleMapMouseEvent(mouseEvent));
            await marker.AddTo(map);
            MapMarkers.Add(marker);
        }
    }

    void ValidateYear(ValidatorEventArgs e)
    {
        var year = Convert.ToString(e.Value);

        e.Status = string.IsNullOrEmpty(year) ? ValidationStatus.None :
            year.Length == 4 ? ValidationStatus.Success : ValidationStatus.Error;
    }

    private async Task HandleMapMouseEvent(MouseEvent mouseEvent)
    {
        var lat = Math.Round(mouseEvent.LatLng.Lat, 1);
        var lng = Math.Round(mouseEvent.LatLng.Lng, 1);
        var newLocation = Locations.Single(x => Math.Round(x.Coordinates.Latitude, 1) == lat && Math.Round(x.Coordinates.Longitude, 1) == lng);
        await SelectedLocationChanged(newLocation.Id);
    }

    protected override async Task OnInitializedAsync()
    {
        SelectedResolution = DataResolution.Yearly;
        if (DataService == null)
        {
            throw new NullReferenceException(nameof(DataService));
        }
        DataSetDefinitions = (await DataService.GetDataSetDefinitions()).ToList();
        Locations = (await DataService.GetLocations()).ToList();

        if (MapMarkers == null)
        {
            await CreateMapMarkers();
        }
        Datasets = new List<DataSet>();
        SelectedYears = new List<short>();

        var uri = NavManager.ToAbsoluteUri(NavManager.Uri);
        if (QueryHelpers.ParseQuery(uri.Query).TryGetValue("locationId", out var locationIdStringValues))
        {
            await SelectedLocationChanged(Guid.Parse(locationIdStringValues.ToString()));
        }
        else
        {
            await SelectedLocationChanged(Guid.Parse("e069a5df-8f9e-47d6-a53b-dba5dd4e618c"));
        }

        await base.OnInitializedAsync();
    }

    protected async Task BuildLocationDataSets()
    {
        var dataExists = false;
        Datasets = new List<DataSet>();
        if (Datasets == null)
        {
            throw new NullReferenceException(nameof(Datasets));
        }

        var relativeToAverage = SelectedChartType == ChartType.Bar;

        var existingDatasets = Datasets.Where(x => x.Resolution == DataResolution.Yearly && x.Location.Id == SelectedLocationId);
        dataExists = existingDatasets.Any();
        if (!dataExists)
        {
            var adjusted = (await DataService.GetDataSet(DataResolution.Yearly, MeasurementType.Adjusted, SelectedLocationId, dayGrouping: SelectedDayGrouping, threshold: SelectedDayGroupThreshold, relativeToAverage: relativeToAverage)).ToList();
            Datasets.AddRange(adjusted);

            var unadjusted = (await DataService.GetDataSet(DataResolution.Yearly, MeasurementType.Unadjusted, SelectedLocationId, dayGrouping: SelectedDayGrouping, threshold: SelectedDayGroupThreshold, relativeToAverage: relativeToAverage)).ToList();
            Datasets.AddRange(unadjusted);

            if (Difference)
            {
                var difference = new DataSet
                    {
                        Resolution = DataResolution.Yearly,
                        MeasurementType = MeasurementType.Difference,
                    };
                unadjusted.ForEach(x =>
                    {
                        x.Temperatures.ForEach(y =>
                        {
                            var adjustedTemp = adjusted.Single().Temperatures.SingleOrDefault(z => z.Year == y.Year);
                            difference.Temperatures.Add(new TemperatureRecord
                            {
                                Year = y.Year,
                                Max = adjustedTemp == null ? null : adjustedTemp.Max - y.Max,
                                Min = adjustedTemp == null ? null : adjustedTemp.Min - y.Min,
                            });
                        });
                    }
                );

                Datasets.Add(difference);
            }

            var adjustedYears = adjusted.SingleOrDefault()?.Years;
            var unadjustedYears = unadjusted.SelectMany(x => x.Years).Distinct();
            DatasetYears = adjustedYears == null ? unadjustedYears.ToList()
                                                 : adjustedYears.Concat(unadjustedYears).Distinct().OrderBy(x => x).ToList();
        }

        foreach (var selectedYear in SelectedYears)
        {
            var yearsExists = existingDatasets.Any(x => x.Year.HasValue && x.Year.Value == selectedYear);
            if (!yearsExists)
            {
                var adjustedTemps = (await DataService.GetDataSet(SelectedResolution, MeasurementType.Adjusted, SelectedLocationId, selectedYear, dayGrouping: SelectedDayGrouping, threshold: SelectedDayGroupThreshold, relativeToAverage: relativeToAverage)).ToList();
                Datasets.AddRange(adjustedTemps);

                var unadjustedTemps = (await DataService.GetDataSet(SelectedResolution, MeasurementType.Unadjusted, SelectedLocationId, selectedYear, dayGrouping: SelectedDayGrouping, threshold: SelectedDayGroupThreshold, relativeToAverage: relativeToAverage)).ToList();
                Datasets.AddRange(unadjustedTemps);
            }
        }

        StationsWithData = Datasets.Where(x => x.MeasurementType == MeasurementType.Unadjusted && !string.IsNullOrWhiteSpace(x.Station))
                    .Select(x => x.Station)
                    .Distinct()
                    .ToList();

        SelectedStation = StationsWithData.FirstOrDefault();

        await map.SetView(new LatLng(SelectedLocation.Coordinates.Latitude, SelectedLocation.Coordinates.Longitude));

        await HandleRedraw();
    }

    Chart<float?> chart;

    async Task OnStartYearTextChanged(string text)
    {
        StartYear = text;
        if (text.Length == 0 || text.Length == 4)
        {
            await HandleRedraw();
        }
    }

    async Task OnEndYearTextChanged(string text)
    {
        EndYear = text;
        if (text.Length == 0 || text.Length == 4)
        {
            await HandleRedraw();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await HandleRedraw();
        }
    }

    async Task HandleRedraw()
    {
        if (Datasets == null)
        {
            return;
        }

        colours = new ColourServer();

        var labels = new string[0];
        var unadjustedMaximums = new List<float?>();
        var unadjustedMinimums = new List<float?>();
        var adjustedMaximums = new List<float?>();
        var adjustedMinimums = new List<float?>();

        string title = string.Empty;

        await chart.Clear();

        List<DataSet> bufferedSelectedDataSet = new List<DataSet>();
        Func<TemperatureRecord, bool> timeConstraint = null;

        if (SelectedResolution == DataResolution.Yearly)
        {
            var selectedDataSets = Datasets.Where(x => x.Resolution == DataResolution.Yearly && ((Adjusted && x.MeasurementType == MeasurementType.Adjusted) || (Unadjusted && x.MeasurementType == MeasurementType.Unadjusted) || (Difference && x.MeasurementType == MeasurementType.Difference)))
                                           .ToList();

            bufferedSelectedDataSet = CreateStandardisedDataSet(selectedDataSets);

            var superSetStartYear = bufferedSelectedDataSet.Min(x => x.Temperatures.Min(y => y.Year));
            var superSetEndYear = bufferedSelectedDataSet.Max(x => x.Temperatures.Max(y => y.Year));

            var userStartYear = string.IsNullOrEmpty(StartYear) ? null : (short?)short.Parse(StartYear);
            var userEndYear = string.IsNullOrEmpty(EndYear) ? null : (short?)short.Parse(EndYear);

            var startYear = superSetStartYear;
            var endYear = superSetEndYear;
            if (userStartYear != null)
            {
                if (userStartYear >= superSetStartYear && userStartYear <= superSetEndYear)
                {
                    startYear = userStartYear.Value;
                }
            }

            if (userEndYear != null)
            {
                if (userEndYear > superSetStartYear && userEndYear <= superSetEndYear)
                {
                    endYear = userEndYear.Value;
                }
            }

            title = SelectedChartType == ChartType.Line ? $"Average Yearly Temperature for {SelectedLocation.Name} ({startYear}-{endYear})"
                                                        : $"Temperature Relative to Average for {SelectedLocation.Name} ({startYear}-{endYear})";

            StartYearOfChart = startYear;

            timeConstraint = x => x.Year >= startYear && x.Year <= endYear;

            var numberOfYears = endYear - startYear;
            labels = new string[numberOfYears + 1];
            for (var i = 0; i <= numberOfYears; i++)
            {
                labels[i] = (startYear + i).ToString();
            }

            Labels = labels;
            await chart.AddLabels(Labels);

            await AddDataSetsToGraph(bufferedSelectedDataSet, timeConstraint);
        }
        else
        {
            var selectedDataSets = Datasets.Where(x => x.Resolution == SelectedResolution
                && ((Adjusted && x.MeasurementType == MeasurementType.Adjusted) || (Unadjusted && x.MeasurementType == MeasurementType.Unadjusted))
                && x.Temperatures.All(y => SelectedYears.Contains(y.Year))).ToList();

            foreach (var dataSet in selectedDataSets)
            {
                if (dataSet.MeasurementType == MeasurementType.Adjusted)
                {
                    bufferedSelectedDataSet.Add(dataSet);
                }
                else
                {
                    if (dataSet.Station == SelectedStation)
                    {
                        bufferedSelectedDataSet.Add(dataSet);
                    }
                }
            }

            title = $"{string.Join(", ", SelectedYears)} {SelectedResolution} Temperature for {SelectedLocation.Name}";        

            var calendar = new GregorianCalendar();

            if (SelectedYears.Any())
            {
                var selectedYear = SelectedYears.FirstOrDefault(x => calendar.IsLeapYear(x));

                if (selectedYear == 0)
                {
                    selectedYear = SelectedYears.First();
                }

                switch (SelectedResolution)
                {
                    case DataResolution.Daily:
                        {
                            var numberOfDays = calendar.GetDaysInYear(selectedYear);
                            labels = new string[numberOfDays];
                            var date = new DateOnly(selectedYear, 1, 1);
                            for (var i = 0; i < numberOfDays; i++)
                            {
                                labels[i] = date.ToString("dd/MM");
                                date = date.AddDays(1);
                            }
                            break;
                        }
                    case DataResolution.Weekly:
                        {
                            labels = new string[52];
                            for (var i = 0; i < 52; i++)
                            {
                                labels[i] = $"Week {i + 1}";
                            }
                            break;
                        }
                    case DataResolution.Monthly:
                        {
                            labels = new string[12];
                            for (var i = 0; i < 12; i++)
                            {
                                labels[i] = new DateTime(2010, i + 1, 1).ToString("MMMM", CultureInfo.InvariantCulture);
                            }
                            break;
                        }
                }
            }

            Labels = labels;
            await chart.AddLabels(Labels);

            for (var i = 0; i < SelectedYears.Count; i++)
            {

                var year = SelectedYears[i];
                if (!bufferedSelectedDataSet.Any(x => x.Year == year))
                {
                    continue;
                }
                timeConstraint = x => x.Year == year;
                await AddDataSetsToGraph(bufferedSelectedDataSet, timeConstraint, year.ToString(), year, (short)(96 * (i + 1)));
            }
        }

        var yLabel = SelectedChartType == ChartType.Line ? "Degrees Celsius (°C)" : "Degrees Celsius (°C) Relative to Average Temperature";
        var xLabel = GetXAxisLabel();

        object chartOptions = new
        {
            SpanGaps = true,
            Title = new 
            { 
                Text = title,
                Display = true
            },
            Scales = new
            {
                YAxes = new []
                { 
                    new  
                    { 
                        ScaleLabel = new { LabelString = yLabel, Display = true } 
                    } 
                },
                XAxes = new []
                { 
                    new 
                    { 
                        ScaleLabel = new { LabelString = xLabel, Display = true } 
                    } 
                }       
            }
        };

        await chart.SetOptionsObject(chartOptions);

        await chart.Update();
    }

    string GetXAxisLabel()
    {
        switch (SelectedResolution)
        {
            case DataResolution.Yearly:
                return "Year";
            case DataResolution.Monthly:
                return "Month";
            case DataResolution.Weekly:
                return "Week";
            case DataResolution.Daily:
                return "Date (dd/mm)";
        }
        throw new Exception();
    }

    async Task AddDataSetsToGraph(List<DataSet> bufferedSelectedDataSet, Func<TemperatureRecord, bool> timeConstraint, string? labelPrefix = null, short? year = null, short colourAdjust = 0)
    {
        if (!string.IsNullOrWhiteSpace(labelPrefix))
        {
            labelPrefix += " ";
        }
        if (Adjusted && Maximums)
        {
            var values = SelectTemperatureValues(bufferedSelectedDataSet, MeasurementType.Adjusted, y => y.Max, timeConstraint, year);
            var label = labelPrefix + "Maximum Adjusted";
            var colour = ChartColor.FromHtmlColorCode(colours.GetNextColour(0));
            if (SelectedPeriod == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, colour));
            }
            await AddMovingAverage(label, values);
        }
        if (Unadjusted && Maximums)
        {
            var values = SelectTemperatureValues(bufferedSelectedDataSet, MeasurementType.Unadjusted, y => y.Max, timeConstraint, year);
            var label = labelPrefix + "Maximum Unadjusted";
            var colour = ChartColor.FromHtmlColorCode(colours.GetNextColour(1));
            if (SelectedPeriod == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, colour));
            }
            await AddMovingAverage(label, values);
        }
        if (Difference && Maximums)
        {
            var values = SelectTemperatureValues(bufferedSelectedDataSet, MeasurementType.Difference, y => y.Max, timeConstraint, year);
            var label = labelPrefix + "Maximum Difference";
            if (SelectedPeriod == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, chartType: ChartType.Bar));
            }
        }
        if (Adjusted && Minimums)
        {
            var values = SelectTemperatureValues(bufferedSelectedDataSet, MeasurementType.Adjusted, y => y.Min, timeConstraint, year);
            var label = labelPrefix + "Minimum Adjusted";
            var colour = ChartColor.FromHtmlColorCode(colours.GetNextColour(2));
            if (SelectedPeriod == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, colour));
            }
            await AddMovingAverage(label, values);
        }
        if (Unadjusted && Minimums)
        {
            var values =  SelectTemperatureValues(bufferedSelectedDataSet, MeasurementType.Unadjusted, y => y.Min, timeConstraint, year);
            var label = labelPrefix + "Minimum Unadjusted";
            var colour = ChartColor.FromHtmlColorCode(colours.GetNextColour(3));
            if (SelectedPeriod == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, colour));
            }
            await AddMovingAverage(label, values);
        }
    }

    async Task AddMovingAverage(string label, List<float?> values)
    {
        if (SelectedChartType == ChartType.Line && SelectedPeriod != 0)
        {
            var simpleMovingAverages = SimpleMovingAverage.Calculate(SelectedPeriod, values);
            label = $"{label} Moving Average @ {SelectedPeriod} year interval";
            await chart.AddDataSet(GetLineChartDataset(label, simpleMovingAverages, ChartColor.FromHtmlColorCode(colours.GetNextColour())));
        }
    }

    List<float?> SelectTemperatureValues(List<DataSet> dataSet, MeasurementType measurementType, Func<TemperatureRecord, float?> selector, Func<TemperatureRecord, bool> timeConstraint, short? year = null)
    {
        var dataset = dataSet.SingleOrDefault(x => x.MeasurementType == measurementType && (year == null || x.Year == year.Value));

        var selectedValues = dataset
                            .Temperatures
                            .Where(timeConstraint)
                            .Select(selector)
                            .ToList();

        return selectedValues;
    }

    List<DataSet> CreateStandardisedDataSet(List<DataSet> dataSets)
    {
        var bufferedDataSets = new List<DataSet>();

        var superSetStartYear = dataSets.Min(x => x.Temperatures.Min(y => y.Year));
        var superSetEndYear = dataSets.Max(x => x.Temperatures.Max(y => y.Year));

        foreach (var dataSet in dataSets)
        {
            var temperatures = new List<TemperatureRecord>();
            for (var year = superSetStartYear; year < superSetEndYear; year++)
            {
                var record = dataSet.Temperatures.FirstOrDefault(x => x.Year == year);
                if (record == null)
                {
                    record = new TemperatureRecord
                    {
                        Year = year,
                        Min = null,
                        Max = null,
                    };
                }
                temperatures.Add(record);
            }
            var bufferedDataSet = new DataSet { Location = dataSet.Location, MeasurementType = dataSet.MeasurementType };
            bufferedDataSet.Temperatures = temperatures;
            bufferedDataSets.Add(bufferedDataSet);
        }
        return bufferedDataSets;
    }

    List<DataSet> CreateDailyBufferedDataSet(List<DataSet> dataSets)
    {
        var bufferedDataSets = new List<DataSet>();

        var startDate = new DateOnly(dataSets.Min(x => x.Temperatures.Min(y => y.Year)), 1, 1);
        foreach(var dataSet in dataSets)
        {
            var bufferedDataSet = new DataSet { Location = dataSet.Location, MeasurementType = dataSet.MeasurementType };
            bufferedDataSets.Add(bufferedDataSet);

            var startYear = dataSet.Temperatures.Min(x => x.Date);
            var temperatures = new List<TemperatureRecord>();
            //for (var i = superSetStartYear; i < startYear; i++)
            //{
            //    temperatures.Add(new DailyTemperatureRecord { Date = i });
            //}
            temperatures.AddRange(dataSet.Temperatures);
            bufferedDataSet.Temperatures = temperatures;
        }

        return bufferedDataSets;
    }

    ChartDataset<float?> GetChartDataset(string label, List<float?> values, ChartColor? chartColour = null, ChartType? chartType = null, bool? absoluteValues = false)
    {
        chartType = chartType == null ? SelectedChartType : chartType;
        switch (chartType)
        {
            case ChartType.Line:
                {
                    return GetLineChartDataset(label, values, chartColour.Value);
                }
            case ChartType.Bar:
                {
                    return GetBarChartDataset(label, values, absoluteValues);
                }
        }
        throw new NotImplementedException();
    }

    BarChartDataset<float?> GetBarChartDataset(string label, List<float?> values, bool? absoluteValues)
    {
        var colour = Enso.GetBarChartColourSet(values);

        return new BarChartDataset<float?>
                    {
                        Label = label,
                        Data = values.Select(x => absoluteValues.GetValueOrDefault() && x.HasValue ? MathF.Abs(x.Value) : x).ToList(),
                        BorderColor = colour,
                        BackgroundColor = colour,
                    };
    }

    LineChartDataset<float?> GetLineChartDataset(string label, List<float?> values, ChartColor chartColor)
    {
        var count = values.Count;
        var colour = new List<string>();
        for (var i = 0; i < count; i++)
            colour.Add(chartColor);

        return new LineChartDataset<float?>
                    {
                        Label = label,
                        Data = values,
                        BorderColor = colour,
                        Fill = false,
                        PointRadius = 5,
                        BorderDash = new List<int> { },
                        LineTension = 0.1f,
                    };
    }

    async Task SelectedLocationChanged(Guid newValue)
    {
        SelectedLocationId = newValue;
        SelectedLocation = Locations.Single(x => x.Id == SelectedLocationId);
        SelectedDataSetDefinition = DataSetDefinitions.Single(x => x.Id == SelectedLocation.DataSetId);

        if (SelectedDataSetDefinition.MeasurementTypes.Count == 2)
        {
            UnadjustedDisabled = false;
            AdjustedDisabled = false;
            DifferenceDisabled = false;
        }
        else
        {
            Unadjusted = SelectedDataSetDefinition.MeasurementTypes.Contains(MeasurementType.Unadjusted);
            Adjusted = SelectedDataSetDefinition.MeasurementTypes.Contains(MeasurementType.Adjusted);
            UnadjustedDisabled = true;
            AdjustedDisabled = true;
            DifferenceDisabled = true;
        }

        base.StateHasChanged();
        await BuildLocationDataSets();
    }

    string[] Labels = new string[1];

    private Map map;

    private MapOptions mapOptions = new MapOptions()
    {
        DivId = "mapId",
        Center = new LatLng(-25.6, 134.3),
        Zoom = 6,
        UrlTileLayer = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
	    SubOptions = new MapSubOptions()
        {
            Attribution = "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
            TileSize = 512,
            ZoomOffset = -1,
            MaxZoom = 19,
        }
    };

    [Inject]
    private IMarkerFactory MarkerFactory { get; init; }
    [Inject]
    private IIconFactory IconFactory { get; init; }

    async Task OnLineChartClicked(ChartMouseEventArgs e)
    {
        if (SelectedResolution != DataResolution.Yearly)
        {
            return;
        }

        var model = e.Model as LineChartModel;

        var year = (short)(StartYearOfChart + e.Index);

        SelectedYears = new List<short> { year };

        SelectedResolution = DataResolution.Monthly;

        await BuildLocationDataSets();
    }
}