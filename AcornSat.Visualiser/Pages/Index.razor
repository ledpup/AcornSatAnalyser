@page "/"
@page "/location/{locationId}"

@inject NavigationManager NavManager

@using AcornSat.Core
@using AcornSat.Core.ViewModel
@using AcornSat.Visualiser.UiModel
@using Blazorise
@using Blazorise.Components
@using Blazorise.Charts
@using Blazorise.Charts.Trendline
@using System.IO;
@using System.Globalization
@using static AcornSat.Core.Enums
@using Microsoft.AspNetCore.WebUtilities
@using System.Text
@using DPBlazorMapLibrary

<PageTitle>@GetPageTitle()</PageTitle>

<div>
    <div class="map-space-reserver" id="mapContainerContainer">
        <MapContainer
            @ref="mapContainer"
            Locations="@Locations"
            OnLocationChange="@SelectedLocationChanged"></MapContainer>

    </div>
    <div class="location-info-container">
        @if (SelectedLocation != null)
        {
            <LocationInfo
                Location="@SelectedLocation"
                DataSetDefinition="@SelectedDataSetDefinition"
                RequestLocationChange="@ShowSelectLocationModal"
                OnOverviewShowOrHide="@OnOverviewShowHide"></LocationInfo>
        }
    </div>
    <div style="clear: both;"></div>
</div>

<div style="min-height: 40px"></div>

@if (SelectedResolution == DataResolution.Yearly)
{
    <a class="large-link right-margin" @onclick="OnDownloadDataClicked">Download data</a>
}

<a class="large-link right-margin" @onclick="ShowOptionsModal">Chart options</a>
<a class="large-link right-margin" @onclick="ShowFilterModal">Year filtering</a>

<ChartSeriesListView ChartSeriesList="ChartSeriesList" OnSeriesChanged="@BuildDataSets"></ChartSeriesListView>

<div class="chart">
    <Chart @ref="chart" TItem="float?" Clicked="@OnLineChartClicked" Type="ChartType.Line">
        <ChartTrendline @ref="chartTrendline" TItem="float?" />
    </Chart>
</div>
 
<SelectLocation
    @ref="selectLocationModal"
    Locations="@Locations"
    SelectedLocation="@SelectedLocation"
    OnLocationChange="@SelectedLocationChanged"
    />

 <Modal @ref="optionsModal">
    <ModalContent>
        <ModalHeader Background="Background.Light">
            <ModalTitle>Options</ModalTitle>
            <CloseButton />
        </ModalHeader>
        <ModalBody>
            <Alert Color="Color.Success" Visible="true">
                Chart Type
                <RadioGroup TValue="ChartType" CheckedValue="@SelectedChartType" CheckedValueChanged="@OnSelectedChartTypeValueChanged" Orientation="Orientation.Vertical">
                    <Radio TValue="ChartType" Value="ChartType.Line">Line chart</Radio>
                    <Radio TValue="ChartType" Value="ChartType.Bar">Bar chart - relative to average</Radio>
                </RadioGroup>
                <Check TValue="bool" Checked="@trendlinesOn" CheckedChanged="@OnTrendlinesButtonClicked">Trendline</Check>
            </Alert>
           <Alert Color="Color.Primary" Visible="true">
                Data Types

                <Check TValue="bool" Checked="@Maximums" CheckedChanged="@OnMaximumsChanged">Maximum Temperatures</Check>
                <Check TValue="bool" Checked="@Minimums" CheckedChanged="@OnMinimumsChanged">Minimum Temperatures</Check>
                <Check TValue="bool" Checked="@Rainfall" CheckedChanged="@OnRainfallChanged">Rainfall</Check>
                <Check TValue="bool" Checked="@CO2" CheckedChanged="@OnCO2Changed">CO₂</Check>
                <Check TValue="bool" Checked="@CH4" CheckedChanged="@OnCH4Changed">CH₄</Check>
                <Check TValue="bool" Checked="@N2O" CheckedChanged="@OnN2OChanged">N₂O</Check>

                @if(!Maximums && !Minimums && !Rainfall && !CO2 && !CH4 && !N2O)
                {
                    <div style="color: red">No data types selected - select a data type to display data on the chart</div>
                }

           </Alert>
           <Alert Color="Color.Secondary" Visible="true">
                Data Adjustment

                <Check TValue="bool" Checked="@Unadjusted" CheckedChanged="@OnUnadjustedChanged" Disabled="@UnadjustedDisabled">Unadjusted</Check>
                <Check TValue="bool" Checked="@Adjusted" CheckedChanged="@OnAdjustedChanged"  Disabled="@AdjustedDisabled">Adjusted</Check>
                <Check TValue="bool" Checked="@Difference" CheckedChanged="@OnDifferenceChanged"  Disabled="@DifferenceDisabled">Difference (adjusted vs unadjusted)</Check>

                @if(!Unadjusted && !Adjusted && !Difference)
                {
                    <div style="color: red">No adjustment types selected - select an adjustment to display data on the chart</div>
                }
            </Alert>
            <Alert Color="Color.Info" Visible="true">
                Simple Moving Average<br/>
                <Select TValue="int" SelectedValue="@SelectedMovingAverageInterval" SelectedValueChanged="@OnSelectedPeriodChanged">
                    <SelectItem Value="0">None</SelectItem>
                    <SelectItem Value="3">3 years</SelectItem>
                    <SelectItem Value="5">5 years</SelectItem>
                    <SelectItem Value="7">7 years</SelectItem>
                    <SelectItem Value="10">10 years</SelectItem>
                </Select>
                <Check TValue="bool" Checked="@SoloSma" CheckedChanged="@OnSoloSmaChanged">Solo</Check>
            </Alert>
            <Alert Color="Color.Danger" Visible="true">
                Day grouping<br/>
                <Select TValue="short" SelectedValue="@SelectedDayGrouping" SelectedValueChanged="@OnSelectingDayGroupingChanged">
                    <SelectItem Value="5">@DayGroupingText(5)</SelectItem>
                    <SelectItem Value="7">@DayGroupingText(7)</SelectItem>
                    <SelectItem Value="13">@DayGroupingText(13)</SelectItem>
                    <SelectItem Value="14">@DayGroupingText(14)</SelectItem>
                    <SelectItem Value="26">@DayGroupingText(26)</SelectItem>
                    <SelectItem Value="28">@DayGroupingText(28)</SelectItem>
                    <SelectItem Value="73">@DayGroupingText(73)</SelectItem>
                    <SelectItem Value="91">@DayGroupingText(91)</SelectItem>
                    <SelectItem Value="182">@DayGroupingText(182)</SelectItem>
                </Select>
                Threshold required to form a valid group (% percentage)<br/>
                <TextEdit Text="@DayGroupThresholdText" TextChanged="@OnDayGroupThresholdTextChanged" MaskType="MaskType.RegEx" EditMask="^[1-9][0-9]?$|^100$" MaxLength="3" />
                <Button Color="Color.Primary" Clicked="@ApplyYearlyAverageParameters">Apply</Button>
            </Alert>
        </ModalBody>
    </ModalContent>
</Modal>

<Filter
    @ref="filter"
    DatasetYears="@DatasetYears"
    SelectedYears="@SelectedYears"
    SelectedStartYear="@SelectedStartYear"
    SelectedEndYear="@SelectedEndYear"
    SelectedResolution="@SelectedResolution"
    OnSelectedYearsChanged="@OnSelectedYearsChanged"
    OnSelectedResolutionChanged="@OnSelectedResolutionChanged"
    OnStartYearTextChanged="@OnStartYearTextChanged"
    OnEndYearTextChanged="@OnEndYearTextChanged"
    ></Filter>

@code{
    [Parameter]
    public string LocationId { get; set; }

    bool trendlinesOn = true;

    @inject IJSRuntime JSRuntime
    @inject ILogger<Index> Logger;

    string GetPageTitle()
    {
        var locationText = SelectedLocation == null ? "" : " - " + SelectedLocation.Name;
        return $"Climate explorer{ locationText }";
    }

    async Task OnTrendlinesButtonClicked()
    {
        trendlinesOn = !trendlinesOn;

        await HandleRedraw();
    }

    string DayGroupingText(int dayGrouping)
    {
        switch (dayGrouping)
        {
            case 5:
                return "Groups of 5 days (73 groups)";
            case 7:
                return "Groups of 7 days (52 groups)";
            case 13: 
                return "Groups of 13 days (28 groups)";
            case 14:
                return "Groups of 14 days (26 groups)";
            case 26:
                return "Groups of 26 days (14 groups)";
            case 28:
                return "Groups of 28 days (13 groups)";
            case 73:
                return "Groups of 73 days (5 groups)";
            case 91:
                return "Groups of 91 days (4 groups)";
            case 182:
                return "Groups of 182 days (2 groups)";
        }
        throw new NotImplementedException(dayGrouping.ToString());
    }

    Stream GetFileStream()
    {
        var resolution = SelectedChartType == ChartType.Line ? "Yearly average" : "Yearly values relative to average";

        var data = new List<string> { $"{SelectedLocation.Name},{SelectedLocation.Coordinates.ToString(true)}" };

        data.Add($"{resolution},{ChartStartYear}-{ChartEndYear},Averaging method: {DayGroupingText(SelectedDayGrouping).ToLower()} with a threshold of {SelectedDayGroupThreshold},average requiring all groupings for a full data set - otherwise record null");
        data.Add(string.Empty);

        var header = "Year," + string.Join(",", CorrelatedDataSets.Select(x => $"{x.MeasurementDefinition.DataType} {x.MeasurementDefinition.DataAdjustment}"));
        data.Add(header);

        foreach (var label in GetLabels(DataResolution.Yearly, ChartStartYear, ChartEndYear))
        {
            var dataRow = label + ",";
            foreach (var dataSet in CorrelatedDataSets)
            {
                var dataRecord = dataSet.DataRecords.Single(x => x.Year == short.Parse(label));
                dataRow += (dataRecord.Value == null ? string.Empty : MathF.Round((float)dataRecord.Value, 2).ToString("0.00")) + ",";
            }
            dataRow = dataRow.TrimEnd(',');
            data.Add(dataRow);
        }

        var bytes = data.SelectMany(s => System.Text.Encoding.UTF8.GetBytes(s + Environment.NewLine)).ToArray();
        var fileStream = new MemoryStream(bytes);

        return fileStream;
    }

    private async Task OnDownloadDataClicked()
    {
        var fileStream = GetFileStream();
        var fileName = $"{SelectedLocation.Name} {ChartStartYear}-{ChartEndYear}.csv";

        using var streamRef = new DotNetStreamReference(stream: fileStream);

        await JSRuntime.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    float SelectedDayGroupThreshold { get; set; } = .7f;
    string DayGroupThresholdText { get; set; }
    short SelectedDayGrouping { get; set; } = 14;
    short SelectingDayGrouping { get; set; }

    async Task OnSelectingDayGroupingChanged(short value)
    {
        SelectingDayGrouping = value;
    }

    async Task OnDayGroupThresholdTextChanged(string value)
    {
        DayGroupThresholdText = value;
    }

    async Task ApplyYearlyAverageParameters()
    {
        SelectedDayGroupThreshold = float.Parse(DayGroupThresholdText) / 100;
        SelectedDayGrouping = SelectingDayGrouping == 0 ? SelectedDayGrouping : SelectingDayGrouping;
        await BuildDataSetsInSimpleMode();
    }

    private MapContainer mapContainer;

    private async Task OnOverviewShowHide(bool isOverviewVisible)
    {
        await JSRuntime.InvokeVoidAsync("showOrHideMap", isOverviewVisible);
    }

    private SelectLocation selectLocationModal;

    private Task ShowSelectLocationModal()
    {
        return selectLocationModal.Show();
    }

    private Task HideSelectLocationModal()
    {
        return selectLocationModal.Hide();
    }

    private Modal optionsModal;
    private Task ShowOptionsModal()
    {
        DayGroupThresholdText = (SelectedDayGroupThreshold * 100).ToString();
        return optionsModal.Show();
    }

    private Task HideOptionsModal()
    {
        return optionsModal.Hide();
    }

    Filter filter;

    async Task ShowFilterModal()
    {
        await filter.Show();
    }

    async Task HideFilterModal()
    {
        await filter.Hide();
    }

    /// <summary>
    /// The chart type applied to the chart control. This depends both on which chart
    /// type the user has selected and whether or not the "Difference" channel has been
    /// enabled (if the "Difference" channel is enabled, then the chart has to be placed
    /// in "Bar" mode, or else the Difference bars don't render).
    ///
    /// You might wonder why we don't just always leave the chart in "Bar" mode. We did,
    /// actually, but then we noticed that in "Bar" mode, there's a small misalignment
    /// between grid lines and the datapoints.
    /// </summary>
    ChartType InternalChartType { get; set; }

    /// <summary>
    /// The chart type selected by the user on the options page
    /// </summary>
    ChartType SelectedChartType { get; set; }
    async Task OnSelectedChartTypeValueChanged(ChartType value)
    {
        SelectedChartType = value;

        await UpdateInternalChartType();
    }

    async Task UpdateInternalChartType()
    {
        _haveCalledResizeAtLeastOnce = false;

        var newInternalChartType =
            SelectedChartType == ChartType.Bar || Difference || Rainfall
            ? ChartType.Bar
            : ChartType.Line;

        if (newInternalChartType != InternalChartType)
        {
            InternalChartType = newInternalChartType;

            await chart.ChangeType(newInternalChartType);
        }

        await BuildDataSetsInSimpleMode();
    }

    List<short>? DatasetYears { get; set; }
    List<short>? SelectedYears;

    async Task OnSelectedYearsChanged(List<short> values)
    {
        if (!SelectedYears.Any() && values.Count == 0)
        {
            SelectedResolution = DataResolution.Yearly;
            await InvokeAsync(StateHasChanged);
            await BuildDataSetsInSimpleMode();
            return;
        }

        var validValues = new List<short>();
        foreach (var value in values)
        {
            if (DatasetYears.Any(x => x == value))
            {
                validValues.Add(value);
            }
        }
        SelectedYears = validValues;

        if (SelectedResolution == DataResolution.Yearly)
        {
            SelectedResolution = DataResolution.Monthly;
        }

        await InvokeAsync(StateHasChanged);
        await BuildDataSetsInSimpleMode();
    }

    List<string> StationsWithData { get; set; }

    DataResolution SelectedResolution { get; set; }
    async Task OnSelectedResolutionChanged(DataResolution value)
    {
        SelectedResolution = value;
        if (SelectedResolution == DataResolution.Yearly)
        {
            SelectedYears = new List<short>();
        }
        await BuildDataSetsInSimpleMode();
    }

    int SelectedMovingAverageInterval;
    async Task OnSelectedPeriodChanged(int value)
    {
        SelectedMovingAverageInterval = value;
        await HandleRedraw();
    }

    bool SoloSma;
    async Task OnSoloSmaChanged(bool value)
    {
        SoloSma = value;
        await HandleRedraw();
    }

    bool Adjusted = true;
    async Task OnAdjustedChanged(bool value)
    {
        Adjusted = value;
        await BuildDataSetsInSimpleMode();
    }

    bool Unadjusted = false;
    async Task OnUnadjustedChanged(bool value)
    {
        Unadjusted = value;
        await BuildDataSetsInSimpleMode();
    }

    bool Difference = false;
    async Task OnDifferenceChanged(bool value)
    {
        Difference = value;
        await BuildDataSetsInSimpleMode();
    }

    bool UnadjustedDisabled, AdjustedDisabled, DifferenceDisabled;

    bool Maximums = true;
    async Task OnMaximumsChanged(bool value)
    {
        Maximums = value;
        await BuildDataSetsInSimpleMode();
    }

    bool Minimums;
    async Task OnMinimumsChanged(bool value)
    {
        Minimums = value;
        await BuildDataSetsInSimpleMode();
    }

    bool Rainfall;
    async Task OnRainfallChanged(bool value)
    {
        Rainfall = value;
        await UpdateInternalChartType();
    }

    bool CO2;
    async Task OnCO2Changed(bool value)
    {
        CO2 = value;
        await BuildDataSetsInSimpleMode();
    }

    bool CH4;
    async Task OnCH4Changed(bool value)
    {
        CH4 = value;
        await BuildDataSetsInSimpleMode();
    }

    bool N2O;
    async Task OnN2OChanged(bool value)
    {
        N2O = value;
        await BuildDataSetsInSimpleMode();
    }

    string SelectedStartYear { get; set; }
    string SelectedEndYear { get; set; }

    Guid SelectedLocationId { get; set; }
    Location SelectedLocation { get; set; }
    DataSetDefinitionViewModel SelectedDataSetDefinition { get; set; }

    [Inject]
    public IDataService DataService { get; set; }

    List<DataSet> Datasets { get; set; }
    IEnumerable<DataSetDefinitionViewModel> DataSetDefinitions;
    IEnumerable<Location> Locations;
    ColourServer colours = new ColourServer();

    protected override async Task OnInitializedAsync()
    {
        SelectedResolution = DataResolution.Yearly;
        if (DataService == null)
        {
            throw new NullReferenceException(nameof(DataService));
        }
        DataSetDefinitions = (await DataService.GetDataSetDefinitions()).ToList();

        // A cheat: register some 'derived' measurement types. Could be done better.
        var acornSatDsd = DataSetDefinitions.Single(x => x.Id == Guid.Parse("b13afcaf-cdbc-4267-9def-9629c8066321"));

        acornSatDsd.MeasurementDefinitions
            .Add(
                new MeasurementDefinitionViewModel
                {
                    DataAdjustment = DataAdjustment.Difference,
                    DataType = DataType.TempMax,
                    UnitOfMeasure = UnitOfMeasure.DegreesCelsius,
                    PreferredColour = 0
                }
            );

        acornSatDsd.MeasurementDefinitions
            .Add(
                new MeasurementDefinitionViewModel
                {
                    DataAdjustment = DataAdjustment.Difference,
                    DataType = DataType.TempMin,
                    UnitOfMeasure = UnitOfMeasure.DegreesCelsius,
                    PreferredColour = 0
                }
            );

        // Another cheat: Set MeasurementCategory for all MeasurementDefinitions whose DataType is TempMax or TempMin to 
        // Temperature.
        var targets =
            DataSetDefinitions
            .SelectMany(x => x.MeasurementDefinitions)
            .Where(x => x.DataType == DataType.TempMax || x.DataType == DataType.TempMin);

        foreach (var md in targets)
        {
            md.DataCategory = DataCategory.Temperature;
        }

        Locations = (await DataService.GetLocations(includeNearbyLocations: true, includeWarmingMetrics: true)).ToList();

        Datasets = new List<DataSet>();
        SelectedYears = new List<short>();

        var datasetYears = new List<short>();
        for (short i = 1800; i <= (short)DateTime.Now.Year; i++)
        {
            datasetYears.Add(i);
        }
        DatasetYears = datasetYears;

        await base.OnInitializedAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        Logger.LogInformation("OnParametersSetAsync(): " + LocationId);

        Guid locationId = Guid.Parse(LocationId ?? "aed87aa0-1d0c-44aa-8561-cde0fc936395");

        await SelectedLocationChangedInternal(locationId);

        await base.OnParametersSetAsync();
    }

    List<ChartSeriesDefinition> ChartSeriesList { get; set; } = new List<ChartSeriesDefinition>();
    List<SeriesWithData> ChartSeriesWithData { get; set; }

    protected async Task BuildDataSetsInSimpleMode()
    {
        Logger.LogInformation("BuildDataSetsInSimpleMode() entering");

        // Build a list of chart series based on the options the user has specified
        ChartSeriesList = BuildChartSeriesDefinitionsFromSimpleModeUi();

        await BuildDataSets();
    }

    protected async Task BuildDataSets()
    {
        // Fetch the data required to render those series
        ChartSeriesWithData = await RetrieveDataSets(ChartSeriesList);

        // Render those series
        await HandleRedraw();

        await mapContainer.ScrollToPoint(new LatLng(SelectedLocation.Coordinates.Latitude, SelectedLocation.Coordinates.Longitude));

        Logger.LogInformation("BuildDataSetsInSimpleMode() leaving");
    }

    List<ChartSeriesDefinition> BuildChartSeriesDefinitionsFromSimpleModeUi()
    {
        var chartSeriesList = new List<ChartSeriesDefinition>();

        // Save any locked series
        if (ChartSeriesList != null && ChartSeriesList.Any())
        {
            chartSeriesList.AddRange(ChartSeriesList.Where(x => x.IsLocked));
        }

        var anomaly = SelectedChartType == ChartType.Bar;
        var generalAggregationMethod = anomaly ? AggregationMethod.GroupByDayThenAverage_Anomaly : AggregationMethod.GroupByDayThenAverage;

        var selectedDataTypes = CreateSelectedDataTypesList();
        var selectedDataAdjustments = CreateSelectedDataAdjustmentsList();
       
        foreach (var dataType in selectedDataTypes)
        {
            foreach (var dataAdjustment in selectedDataAdjustments)
            {
                var dataDefinition = 
                    dataType == DataType.CO2 || dataType == DataType.CH4 || dataType == DataType.N2O 
                    ? DataSetDefinitions.Single(x => x.MeasurementDefinitions.Any(y => y.DataType == dataType))
                    : SelectedDataSetDefinition;

                var measurementDefinitionsOfRequestedDataType =
                    dataDefinition.MeasurementDefinitions
                    .Where(x => x.DataType == dataType)
                    .ToArray();

                // If the dataset doesn't have measurements of the requested type, don't add a series to the chart
                if (!dataDefinition.MeasurementDefinitions.Any(x => x.DataType == dataType))
                {
                    continue;
                }

                // dataAdjustment is Adjusted, Unadjusted or Difference. If the user asked to display exactly one of the three data adjustment
                // values, but that adjustment is not available for that data type, and there is only adjustment available for that dataType,
                // just use it.
                var requestDataAdjustment = dataAdjustment;
                if (selectedDataAdjustments.Count == 1 && dataDefinition.MeasurementDefinitions.Count(x => x.DataType == dataType) == 1)
                {
                    if (!dataDefinition.MeasurementDefinitions.Any(x => x.DataType == dataType && x.DataAdjustment == dataAdjustment))
                    {
                        requestDataAdjustment = dataDefinition.MeasurementDefinitions.Single(x => x.DataType == dataType).DataAdjustment;
                    }
                }

                var measurementDefinition =
                    dataDefinition.MeasurementDefinitions
                    .SingleOrDefault(x => x.DataType == dataType && x.DataAdjustment == requestDataAdjustment);

                if (measurementDefinition == null)
                {
                    string error = $"No measurement definition of data type {dataType} and adjustment {requestDataAdjustment} (was {dataAdjustment}) available for dataset definition {dataDefinition.Name}";
                    Logger.LogWarning(error);

                    continue;
                }

                var aggregationMethod = dataType == DataType.Rainfall ? AggregationMethod.Sum : generalAggregationMethod;
                Guid? locationId = dataDefinition.HasLocations ? SelectedLocationId : null;
                string locationName = dataDefinition.HasLocations ? SelectedLocation?.Name : null;

                var years = SelectedYears.Any() ? SelectedYears.Select(x => (short?)x).ToList() : new List<short?>() { null };

                // If the user has not selected specific years, we just create one series to span the whole available time.
                // If the user has selected specific years, we create a separate series for each selected year.
                foreach (var year in years)
                {
                    var csd =
                        new ChartSeriesDefinition()
                        {
                            DataSetDefinition = dataDefinition,
                            MeasurementDefinition = measurementDefinition,
                            DataResolution = SelectedResolution,
                            Year = year,
                            LocationId = locationId,
                            LocationName = locationName,
                            Smoothing = SeriesSmoothingOptions.None,
                            SmoothingWindow = 5,
                            Aggregation = MapAggregationMethodToSeriesAggregationOptions(aggregationMethod),
                            Value = anomaly ? SeriesValueOptions.AnomalyRelativeToMean : SeriesValueOptions.Value
                        };
                        
                    chartSeriesList.Add(csd);
                }
            }
        }

        return chartSeriesList;
    }

    public class SeriesWithData
    {
        public ChartSeriesDefinition ChartSeries { get; set;  }
        public List<DataSet> SourceDataSets { get; set; }
        public List<DataSet> ProcessedDataSets { get; set; }
    }

    async Task<List<SeriesWithData>> RetrieveDataSets(List<ChartSeriesDefinition> chartSeriesList)
    {
        var datasetsToReturn = new List<SeriesWithData>();

        foreach (var csd in chartSeriesList)
        {
            var datasets = 
                (await DataService.GetDataSet(
                    csd.MeasurementDefinition.DataType, 
                    csd.DataResolution, 
                    csd.MeasurementDefinition.DataAdjustment, 
                    ChooseDataSetApiAggregationMethod(csd.Aggregation, csd.Value), 
                    csd.LocationId, 
                    csd.Year, 

                    // Ideally, these would be stored at CSD level, but for now, leaving them global
                    dayGrouping: SelectedDayGrouping, 
                    dayGroupingThreshold: SelectedDayGroupThreshold
                ))
                .ToList();

            datasetsToReturn.AddRange(
                datasets
                .Select(x => new SeriesWithData() { ChartSeries = csd, SourceDataSets = datasets })
            );
        }

        return datasetsToReturn;
    }

    static AggregationMethod ChooseDataSetApiAggregationMethod(SeriesAggregationOptions sao, SeriesValueOptions svo)
    {
        switch (sao)
        {
            case SeriesAggregationOptions.Sum:
                return AggregationMethod.Sum;
            case SeriesAggregationOptions.Mean:
                switch (svo)
                {
                    case SeriesValueOptions.Value:
                        return AggregationMethod.GroupByDayThenAverage;
                    case SeriesValueOptions.AnomalyRelativeToMean:
                        return AggregationMethod.GroupByDayThenAverage_Anomaly;
                    default:
                        throw new NotImplementedException($"SeriesValueOptions {svo}");
                }
            default:
                throw new NotImplementedException($"SeriesAggregationOptions {sao}");
        }
    }

    static SeriesAggregationOptions MapAggregationMethodToSeriesAggregationOptions(AggregationMethod m)
    {
        switch (m)
        {
            case AggregationMethod.GroupByDayThenAverage:
            case AggregationMethod.GroupByDayThenAverage_Anomaly:
                return SeriesAggregationOptions.Mean;
            case AggregationMethod.Sum:
                return SeriesAggregationOptions.Sum;
            default:
                throw new NotImplementedException($"AggregationMethod {m}");
        }
    }

    List<DataType> CreateSelectedDataTypesList()
    {
        var selectedDataTypes = new List<DataType>();
        if (Maximums)
        {
            selectedDataTypes.Add(DataType.TempMax);
        }
        if (Minimums)
        {
            selectedDataTypes.Add(DataType.TempMin);
        }
        if (Rainfall)
        {
            selectedDataTypes.Add(DataType.Rainfall);
        }
        if (CO2)
        {
            selectedDataTypes.Add(DataType.CO2);
        }
        if (CH4)
        {
            selectedDataTypes.Add(DataType.CH4);
        }
        if (N2O)
        {
            selectedDataTypes.Add(DataType.N2O);
        }
        return selectedDataTypes;
    }

    List<DataAdjustment> CreateSelectedDataAdjustmentsList()
    {
        var selectedDataAdjustments = new List<DataAdjustment>();

        if (Adjusted)                       selectedDataAdjustments.Add(DataAdjustment.Adjusted);
        if (Unadjusted)                     selectedDataAdjustments.Add(DataAdjustment.Unadjusted);
        if (Difference)                     selectedDataAdjustments.Add(DataAdjustment.Difference);

        return selectedDataAdjustments;
    }

    Chart<float?> chart;
    ChartTrendline<float?> chartTrendline;

    async Task OnStartYearTextChanged(string text)
    {
        SelectedStartYear = text;
        await HandleRedraw();
    }

    async Task OnEndYearTextChanged(string text)
    {
        SelectedEndYear = text;
        
        await HandleRedraw();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await HandleRedraw();
        }
    }

    List<DataSet> CorrelatedDataSets = new List<DataSet>();
    short ChartStartYear, ChartEndYear;

    static Tuple<short, short> CalculateChartStartAndEndYear(
        List<SeriesWithData> chartSeriesWithData,
        string selectedStartYear,
        string selectedEndYear
    )
    {
        // Find the first and least year we have data for
        var superSetStartYear = chartSeriesWithData.SelectMany(x => x.ProcessedDataSets).SelectMany(x => x.DataRecords).Min(y => y.Year);
        var superSetEndYear   = chartSeriesWithData.SelectMany(x => x.ProcessedDataSets).SelectMany(x => x.DataRecords).Max(y => y.Year);

        // Parse the start and end years, if any, specified by the user
        var userStartYear = string.IsNullOrEmpty(selectedStartYear) ? null : (short?)short.Parse(selectedStartYear);
        var userEndYear = string.IsNullOrEmpty(selectedEndYear) ? null : (short?)short.Parse(selectedEndYear);

        // Calculate chart start and end year
        var chartStartYear =
            // If the user specified a year in the range of available data, use it, otherwise, use the first available year
            userStartYear != null && userStartYear >= superSetStartYear && userStartYear <= superSetEndYear
            ? userStartYear.Value
            : superSetStartYear;

        var chartEndYear = 
            // If the user specified a year in the range of available data (not including the first available year) use it,
            // otherwise, use the last available year
            userEndYear != null && userEndYear > superSetStartYear && userEndYear <= superSetEndYear
            ? userEndYear.Value
            : superSetEndYear;

        return new Tuple<short, short>(chartStartYear, chartEndYear);
    }

    async Task HandleRedraw()
    {
        await chart.Clear();

        // This can happen at startup, or if the user switches off all data series
        if (ChartSeriesWithData == null || ChartSeriesWithData.Count == 0)
        {
            return;
        }

        colours = new ColourServer();

        var labels = new string[0];

        var title = string.Empty;
        var subtitle = string.Empty;

        List<ChartTrendlineData> trendlines = null;

        var locationNames = ChartSeriesWithData.Select(x => x.ChartSeries.LocationName).Distinct().ToArray();

        title = ChartSeriesWithData.Count > 1 ? String.Join(", ", locationNames) : ChartSeriesWithData.Single().ChartSeries.FriendlyTitle;

        if (SelectedResolution == DataResolution.Yearly)
        {
            // Data sets sometimes have internal gaps in data (i.e. years which have no data even though earlier
            // and later years have data). Additionally, they may have external gaps in data if the overall period
            // to be charted goes beyond the range of the available data in one particular data set.
            //
            // To ensure these gaps are handled correctly in the plotted chart, we build a new dataset that includes
            // records for each missing year. Value is set to null for those records.
            BuildProcessedDataSetsForYearlyView(ChartSeriesWithData);

            (ChartStartYear, ChartEndYear) = CalculateChartStartAndEndYear(ChartSeriesWithData, SelectedStartYear, SelectedEndYear);

            subtitle = $"({ChartStartYear}-{ChartEndYear})";

            Labels = GetLabels(SelectedResolution, ChartStartYear, ChartEndYear);

            trendlines = await AddDataSetsToGraph();
        }
        else
        {
                    // If the chart is showing only specified years, filter the data sets down to those which are for
        // one of those years.
        // TODO: Review
        var selectedDataSets =
            Datasets.Where(x => !SelectedYears.Any() || SelectedYears.Contains(x.Year.Value))
            .ToList();

            CorrelatedDataSets = new List<DataSet>();
            foreach (var dataSet in selectedDataSets)
            {
                CorrelatedDataSets.Add(dataSet);
            }

            subtitle = $"{string.Join(", ", SelectedYears)} {SelectedResolution} Chart";        

            var calendar = new GregorianCalendar();

            if (SelectedYears.Any())
            {
                var selectedYear = SelectedYears.FirstOrDefault(x => calendar.IsLeapYear(x));

                if (selectedYear == 0)
                {
                    selectedYear = SelectedYears.First();
                }

                labels = GetLabels(SelectedResolution, selectedYear: selectedYear);
                Labels = labels;

                await AddDataSetsToGraph();
            }
        }

        await chart.AddLabels(Labels);

        var xLabel = GetXAxisLabel();

        object scales = new
            {
                X = new
                {
                    Title = new
                    {
                        Text = xLabel,
                        Display = true,
                        Color = "blue",
                    },
                },
                Millimetres = new
                {
                    Display = Rainfall,
                    Axis = "y",
                    Position = Maximums || Minimums ? "right" : "left",
                    Grid = new { DrawOnChartArea = false },
                    Title = new
                    {
                        Text = UnitOfMeasureLabel(UnitOfMeasure.Millimetres),
                        Display = true,
                        Color = "blue",
                    },
                },
                DegreesCelsius = new  
                { 
                    Display = Maximums || Minimums,
                    Axis = "y",
                    Position = "left",
                    Grid = new { DrawOnChartArea = false },
                    Title = new
                    {
                        Text = SelectedChartType == ChartType.Line ? UnitOfMeasureLabel(UnitOfMeasure.DegreesCelsius) : UnitOfMeasureLabel(UnitOfMeasure.DegreesCelsiusAnomaly),
                        Display = true,
                        Color = "blue",
                    },
                },
                PartsPerMillion = new
                {
                    Display = CO2,
                    Axis = "y",
                    Position = Maximums || Minimums ? "right" : "left",
                    Grid = new { DrawOnChartArea = false },
                    Title = new
                    {
                        Text = UnitOfMeasureLabel(UnitOfMeasure.PartsPerMillion),
                        Display = true,
                        Color = "blue",
                    },
                },
                PartsPerBillion = new
                {
                    Display = CH4 || N2O,
                    Axis = "y",
                    Position = Maximums || Minimums ? "right" : "left",
                    Grid = new { DrawOnChartArea = false },
                    Title = new
                    {
                        Text = UnitOfMeasureLabel(UnitOfMeasure.PartsPerBillion),
                        Display = true,
                        Color = "blue",
                    },
                },
            };       

        object chartOptions = new
        {
            Responsive = true,
            MaintainAspectRatio = false,
            SpanGaps = false,
            Plugins = new
            {
                Title = new 
                { 
                    Text = title,
                    Display = true
                },
                Subtitle = new 
                { 
                    Text = subtitle,
                    Display = true
                },
            },
            Scales = scales
        };
        
        await chart.SetOptionsObject(chartOptions);

        await chart.Update();

        if (trendlines != null)
        {
            await chartTrendline.AddTrendLineOptions(trendlines);
        }

        // The below line is required to get the chart.js component to honour the styling applied on the parent div
        // If you don't call resize, the chart will apply the styling only after you resize the window, 
        // but it does not apply the style on the initial load of the page.
        // See https://www.chartjs.org/docs/latest/configuration/responsive.html for more information
        if (!_haveCalledResizeAtLeastOnce)
        {
            await chart.Resize();
            _haveCalledResizeAtLeastOnce = true;
        }
    }

    bool _haveCalledResizeAtLeastOnce = false;

    string[] GetLabels(DataResolution dataResolution, short? chartStartYear = null, short? chartEndYear = null, short? selectedYear = null)
    {
        switch (dataResolution)
        {
            case DataResolution.Yearly:
                {
                    var numberOfYears = chartEndYear.Value - chartStartYear.Value;
                    var labels = new string[numberOfYears + 1];
                    for (var i = 0; i <= numberOfYears; i++)
                    {
                        labels[i] = (chartStartYear.Value + i).ToString();
                    }
                    return labels;
                }
            case DataResolution.Daily:
                {
                    var calendar = new GregorianCalendar();
                    var numberOfDays = calendar.GetDaysInYear(selectedYear.Value);
                    var labels = new string[numberOfDays];
                    var date = new DateOnly(selectedYear.Value, 1, 1);
                    for (var i = 0; i < numberOfDays; i++)
                    {
                        labels[i] = date.ToString("dd/MM");
                        date = date.AddDays(1);
                    }
                    return labels;
                }
            case DataResolution.Weekly:
                {
                    var labels = new string[52];
                    for (var i = 0; i < 52; i++)
                    {
                        labels[i] = $"Week {i + 1}";
                    }
                    return labels;
                }
            case DataResolution.Monthly:
                {
                    var labels = new string[12];
                    for (var i = 0; i < 12; i++)
                    {
                        labels[i] = new DateTime(2010, i + 1, 1).ToString("MMMM", CultureInfo.InvariantCulture);
                    }
                    return labels;
                }
        }
        throw new NotImplementedException();
    }

    string GetXAxisLabel()
    {
        switch (SelectedResolution)
        {
            case DataResolution.Yearly:
                return "Year";
            case DataResolution.Monthly:
                return "Month";
            case DataResolution.Weekly:
                return "Week";
            case DataResolution.Daily:
                return "Date (dd/mm)";
        }
        throw new Exception();
    }

    async Task<List<ChartTrendlineData>> AddDataSetsToGraph()
    {
        var dataSetIndex = 0;

        colours = new ColourServer();
        foreach (var chartSeries in ChartSeriesWithData)
        {
            foreach (var dataSet in chartSeries.ProcessedDataSets)
            {
                await AddDataSetToChart(
                    chartSeries,
                    dataSet,
                    dataSet.DataAdjustment,
                    $"{chartSeries.ChartSeries.FriendlyTitle} {UnitOfMeasureLabelShort(dataSet.MeasurementDefinition.UnitOfMeasure)}",
                    dataSet.MeasurementDefinition.PreferredColour);

                dataSetIndex++;
            }
        }

        //foreach (var dataSet in bufferedSelectedDataSet)
        //{
        //    if (dataSet.Resolution != DataResolution.Yearly)
        //    {
        //        var labelPrefix = dataSet.Year.ToString();
        //        await AddDataSetToChart(dataSet, dataSet.DataAdjustment, $"{labelPrefix} {dataSet.DataType} {dataSet.DataAdjustment} {UnitOfMeasureLabelShort(dataSet.MeasurementDefinition.UnitOfMeasure)}", dataSet.MeasurementDefinition.PreferredColour);
        //        dataSetIndex++;
        //    }
        //    else if (dataSet.DataType == DataType.Rainfall)
        //    {
        //        await AddDataSetToChart(dataSet, dataSet.DataAdjustment, $"{dataSet.DataType} {UnitOfMeasureLabelShort(dataSet.MeasurementDefinition.UnitOfMeasure)}", dataSet.MeasurementDefinition.PreferredColour, redPositive: false);
        //    }
        //    else if (dataSet.DataAdjustment == DataAdjustment.Difference)
        //    {
        //        await AddDataSetToChart(dataSet, DataAdjustment.Difference, $"{dataSet.DataType} Difference {UnitOfMeasureLabelShort(dataSet.MeasurementDefinition.UnitOfMeasure)}", dataSet.MeasurementDefinition.PreferredColour, absoluteValues: true);
        //    }
        //    else
        //    {
        //        await AddDataSetToChart(dataSet, dataSet.DataAdjustment, $"{dataSet.DataType} {dataSet.DataAdjustment} {UnitOfMeasureLabelShort(dataSet.MeasurementDefinition.UnitOfMeasure)}", dataSet.MeasurementDefinition.PreferredColour);
        //        dataSetIndex++;
        //    }
        //}

        var trendlines = new List<ChartTrendlineData>();

        //if (SelectedResolution == DataResolution.Yearly && trendlinesOn)
        //{
        //    var step = 
        //        SelectedChartType == ChartType.Line
        //        ? (SelectedMovingAverageInterval != 0 && !SoloSma ? 2 : 1)
        //        : 1;

        //    colours = new ColourServer();
        //    for (var i = 0; i < dataSetIndex * step; i += step)
        //    {
        //        var preferredColour = bufferedSelectedDataSet[i / step].MeasurementDefinition.PreferredColour;
        //        trendlines.Add(CreateTrendline(i, ChartColor.FromHtmlColorCode(colours.GetNextColour(preferredColour))));
        //    }
        //    if (trendlines.Count == 1)
        //    {
        //        trendlines[0].Color = ChartColor.FromRgba(0, 0, 0, 1f);
        //    }
        //}

        return trendlines;
    }

    async Task AddDataSetToChart(
        SeriesWithData chartSeries,
        DataSet dataSet,
        DataAdjustment dataAdjustment,
        string label,
        int preferredColour,
        bool absoluteValues = false,
        bool redPositive = true)
    {
        var values =
            dataSet.DataRecords
            .Select(x => x.Value)
            .ToList();

        var colour = ChartColor.FromHtmlColorCode(colours.GetNextColour(preferredColour));

        var chartType = 
            (dataAdjustment == DataAdjustment.Difference || dataSet.DataType == DataType.Rainfall) 
            ? ChartType.Bar 
            : SelectedChartType;

        switch (chartSeries.ChartSeries.Smoothing)
        {
            case SeriesSmoothingOptions.None:
                await chart.AddDataSet(
                    GetChartDataset(label, values, dataSet.MeasurementDefinition.UnitOfMeasure, chartType, colour, absoluteValues, redPositive));
                break;

            case SeriesSmoothingOptions.MovingAverage:
                await AddMovingAverage(chartSeries.ChartSeries.SmoothingWindow, label, values, dataSet.MeasurementDefinition.UnitOfMeasure);

                break;
        }
    }

    ChartTrendlineData CreateTrendline(int datasetIndex, ChartColor colour)
    {
        return
            new ChartTrendlineData
                {
                    DatasetIndex = datasetIndex,
                    Width = 3,
                    Color = colour
                };
    }

    async Task AddMovingAverage(int smoothingWindow, string label, List<float?> values, UnitOfMeasure unitOfMeasure)
    {
        var simpleMovingAverages = SimpleMovingAverage.Calculate(smoothingWindow, values);

        label = $"{label} Moving Average @ {smoothingWindow} year interval";

        await chart.AddDataSet(GetLineChartDataset(label, simpleMovingAverages, ChartColor.FromHtmlColorCode(colours.GetNextColour()), unitOfMeasure));
    }

    void BuildProcessedDataSetsForYearlyView(List<SeriesWithData> chartSeriesWithData)
    {
        // Calculate first and last year which we have a data record for, across all data sets underpinning all chart series
        var allDataRecords = chartSeriesWithData.SelectMany(x => x.SourceDataSets).SelectMany(x => x.DataRecords);

        var earliestYearAcrossAllDataSets = allDataRecords.Min(y => y.Year);
        var latestYearAcrossAllDataSets   = allDataRecords.Max(y => y.Year);

        foreach (var cs in chartSeriesWithData)
        {
            // Create new datasets, same as the source, but with any gap years filled with null records
            cs.ProcessedDataSets =
                cs.SourceDataSets
                .Select(
                    x =>
                        new DataSet
                            {
                                Location = x.Location,
                                MeasurementDefinition = x.MeasurementDefinition,
                                DataRecords =
                                    Enumerable.Range(earliestYearAcrossAllDataSets, latestYearAcrossAllDataSets - earliestYearAcrossAllDataSets + 1)
                                    .Select(
                                        year =>
                                            // If there's a record in the source dataset, use it
                                            x.DataRecords.SingleOrDefault(z => z.Year == year)
                                            // Otherwise, create a null record
                                            ?? new DataRecord { Year = (short)year, Value = null }
                                    )
                                    .ToList()
                            }
                )
                .ToList();
        }
    }

    List<DataSet> CreateDailyBufferedDataSet(List<DataSet> dataSets)
    {
        var bufferedDataSets = new List<DataSet>();

        var startDate = new DateOnly(dataSets.Min(x => x.DataRecords.Min(y => y.Year)), 1, 1);
        foreach(var dataSet in dataSets)
        {
            var bufferedDataSet = new DataSet { Location = dataSet.Location, MeasurementDefinition = dataSet.MeasurementDefinition };
            bufferedDataSets.Add(bufferedDataSet);

            var startYear = dataSet.DataRecords.Min(x => x.Date);
            var temperatures = new List<DataRecord>();
            //for (var i = superSetStartYear; i < startYear; i++)
            //{
            //    temperatures.Add(new DailyTemperatureRecord { Date = i });
            //}
            temperatures.AddRange(dataSet.DataRecords);
            bufferedDataSet.DataRecords = temperatures;
        }

        return bufferedDataSets;
    }

    ChartDataset<float?> GetChartDataset(string label, List<float?> values, UnitOfMeasure unitOfMeasure, ChartType chartType, ChartColor? chartColour = null, bool? absoluteValues = false, bool redPositive = true)
    {
        switch (chartType)
        {
            case ChartType.Line:
                if (!chartColour.HasValue)
                {
                    throw new NullReferenceException(nameof(chartColour));
                }
                return GetLineChartDataset(label, values, chartColour.Value, unitOfMeasure);
            case ChartType.Bar:
                return GetBarChartDataset(label, values, unitOfMeasure, absoluteValues, redPositive);
        }

        throw new NotImplementedException();
    }

    BarChartDataset<float?> GetBarChartDataset(string label, List<float?> values, UnitOfMeasure unitOfMeasure, bool? absoluteValues, bool redPositive = true)
    {
        var colour = Enso.GetBarChartColourSet(values, redPositive);

        return new BarChartDataset<float?>
                    {
                        Label = label,
                        Data = values.Select(x => absoluteValues.GetValueOrDefault() && x.HasValue ? MathF.Abs(x.Value) : x).ToList(),
                        BorderColor = colour,
                        BackgroundColor = colour,
                        YAxisID = unitOfMeasure.ToString().ToLowerFirstChar(),
                    };
    }

    LineChartDataset<float?> GetLineChartDataset(string label, List<float?> values, ChartColor chartColor, UnitOfMeasure unitOfMeasure)
    {
        var count = values.Count;
        var colour = new List<string>();
        for (var i = 0; i < count; i++)
            colour.Add(chartColor);

        var lineChartDataset = 
            new LineChartDataset<float?>
            {
                Label = label,
                Data = values,
                BorderColor = colour,
                Fill = false,
                PointRadius = 5,
                BorderDash = new List<int> { },
                Tension = 0.1f,
                YAxisID = unitOfMeasure.ToString().ToLowerFirstChar(),
            };

        return lineChartDataset;
    }

    async Task SelectedLocationChanged(Guid locationId)
    {
        NavManager.NavigateTo("/location/" + locationId.ToString());
    }

    async Task SelectedLocationChangedInternal(Guid newValue)
    {
        Logger.LogInformation("SelectedLocationChangedInternal(): " + newValue);

        SelectedLocationId = newValue;
        SelectedLocation = Locations.Single(x => x.Id == SelectedLocationId);
        SelectedDataSetDefinition = DataSetDefinitions.Single(x => x.Id == SelectedLocation.DataSetId);

        await BuildDataSetsInSimpleMode();
    }

    string[] Labels = new string[1];

    async Task OnLineChartClicked(ChartMouseEventArgs e)
    {
        if (SelectedResolution != DataResolution.Yearly)
        {
            return;
        }

        var year = (short)(ChartStartYear + e.Index);

        SelectedYears = new List<short> { year };
        SelectedResolution = DataResolution.Monthly;

        await BuildDataSetsInSimpleMode();
    }
}