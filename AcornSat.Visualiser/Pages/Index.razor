@page "/"
@inject NavigationManager NavManager
@using AcornSat.Core
@using Blazorise
@using Blazorise.Components
@using Blazorise.Charts
@using Blazorise.Charts.Trendline
@using System.IO;
@using System.Globalization
@using static AcornSat.Core.Enums
@using Microsoft.AspNetCore.WebUtilities
@using System.Text

<PageTitle>Index</PageTitle>

@if (SelectedLocation != null)
{
    <LocationInfo
        Location="@SelectedLocation"
        DataSet="@SelectedDataSetDefinition"
        RequestLocationChange="@ShowSelectLocationModal"
        OnOverviewShowOrHide="@OnOverviewShowHide"></LocationInfo>
}

<div style="min-height: 40px"></div>

@if (SelectedResolution == DataResolution.Yearly)
{
    <a class="large-link right-margin" @onclick="OnDownloadDataClicked">Download data</a>
}

<a class="large-link right-margin" @onclick="ShowOptionsModal">Chart options</a>
<a class="large-link right-margin" @onclick="ShowFilterModal">Year filtering</a>

<div style="position: relative;">
    @* We change the chart's type dynamically depending on selected options.
        We found that changing an existing Chart instance's Type did not always
        cause it to refresh properly.
        So we effectively create a new instance of the chart each time InternalChartType
        changes.
    *@
    @switch (InternalChartType)
    {
        case ChartType.Line:
            <Chart @ref="chart" TItem="float?" Clicked="@OnLineChartClicked" Type="ChartType.Line">
                <ChartTrendline @ref="chartTrendline" TItem="float?" />
            </Chart>
            break;

        case ChartType.Bar:
            <Chart @ref="chart" TItem="float?" Clicked="@OnLineChartClicked" Type="ChartType.Bar">
                <ChartTrendline @ref="chartTrendline" TItem="float?" />
            </Chart>
            break;
    }
</div>
    
<SelectLocation
    @ref="selectLocationModal"
    Locations="@Locations"
    SelectedLocation="@SelectedLocation"
    OnLocationChange="@SelectedLocationChanged"
    />

 <Modal @ref="optionsModal">
    <ModalContent>
        <ModalHeader Background="Background.Light">
            <ModalTitle>Options</ModalTitle>
            <CloseButton />
        </ModalHeader>
        <ModalBody>
            <Alert Color="Color.Success" Visible="true">
                Chart Type
                <RadioGroup TValue="ChartType" CheckedValue="@SelectedChartType" CheckedValueChanged="@OnSelectedChartTypeValueChanged" Orientation="Orientation.Vertical">
                    <Radio TValue="ChartType" Value="ChartType.Line">Line chart</Radio>
                    <Radio TValue="ChartType" Value="ChartType.Bar">Bar chart - relative to average</Radio>
                </RadioGroup>
                <Check TValue="bool" Checked="@trendlinesOn" CheckedChanged="@OnButtonClicked">Trendline</Check>
            </Alert>
           <Alert Color="Color.Primary" Visible="true">
                Data Types
                <Check TValue="bool" Checked="@Maximums" CheckedChanged="@OnMaximumsChanged">Maximum Temperatures</Check>
                <Check TValue="bool" Checked="@Minimums" CheckedChanged="@OnMinimumsChanged">Minimum Temperatures</Check>
                <Check TValue="bool" Checked="@Rainfall" CheckedChanged="@OnRainfallChanged">Rainfall</Check>
           </Alert>
           <Alert Color="Color.Secondary" Visible="true">
                Data Adjustment
                <Check TValue="bool" Checked="@Unadjusted" CheckedChanged="@OnUnadjustedChanged" Disabled="@UnadjustedDisabled">Unadjusted</Check>
                <Check TValue="bool" Checked="@Adjusted" CheckedChanged="@OnAdjustedChanged"  Disabled="@AdjustedDisabled">Adjusted</Check>
                <Check TValue="bool" Checked="@Difference" CheckedChanged="@OnDifferenceChanged"  Disabled="@DifferenceDisabled">Difference - adjusted vs unadjusted</Check>
            </Alert>
            <Alert Color="Color.Info" Visible="true">
                Simple Moving Average<br/>
                <Select TValue="int" SelectedValue="@SelectedMovingAverageInterval" SelectedValueChanged="@OnSelectedPeriodChanged">
                    <SelectItem Value="0">None</SelectItem>
                    <SelectItem Value="3">3 years</SelectItem>
                    <SelectItem Value="5">5 years</SelectItem>
                    <SelectItem Value="7">7 years</SelectItem>
                    <SelectItem Value="10">10 years</SelectItem>
                </Select>
                <Check TValue="bool" Checked="@SoloSma" CheckedChanged="@OnSoloSmaChanged">Solo</Check>
            </Alert>
            <Alert Color="Color.Danger" Visible="true">
                Day grouping<br/>
                <Select TValue="short" SelectedValue="@SelectedDayGrouping" SelectedValueChanged="@OnSelectingDayGroupingChanged">
                    <SelectItem Value="5">@DayGroupingText(5)</SelectItem>
                    <SelectItem Value="7">@DayGroupingText(7)</SelectItem>
                    <SelectItem Value="13">@DayGroupingText(13)</SelectItem>
                    <SelectItem Value="14">@DayGroupingText(14)</SelectItem>
                    <SelectItem Value="26">@DayGroupingText(26)</SelectItem>
                    <SelectItem Value="28">@DayGroupingText(28)</SelectItem>
                    <SelectItem Value="73">@DayGroupingText(73)</SelectItem>
                    <SelectItem Value="91">@DayGroupingText(91)</SelectItem>
                    <SelectItem Value="182">@DayGroupingText(182)</SelectItem>
                </Select>
                Threshold required to form a valid group (% percentage)<br/>
                <TextEdit Text="@DayGroupThresholdText" TextChanged="@OnDayGroupThresholdTextChanged" MaskType="MaskType.RegEx" EditMask="^[1-9][0-9]?$|^100$" MaxLength="3" />
                <Button Color="Color.Primary" Clicked="@ApplyYearlyAverageParameters">Apply</Button>
            </Alert>
        </ModalBody>
    </ModalContent>
</Modal>

<Filter
    @ref="filter"
    DatasetYears="@DatasetYears"
    SelectedYears="@SelectedYears"
    SelectedStartYear="@SelectedStartYear"
    SelectedEndYear="@SelectedEndYear"
    SelectedResolution="@SelectedResolution"
    OnSelectedYearsChanged="@OnSelectedYearsChanged"
    OnSelectedResolutionChanged="@OnSelectedResolutionChanged"
    OnStartYearTextChanged="@OnStartYearTextChanged"
    OnEndYearTextChanged="@OnEndYearTextChanged"
    ></Filter>

<MapContainer
    @ref="mapContainer"
    Locations="@Locations"
    OnLocationChange="@SelectedLocationChanged"></MapContainer>

@code{

    bool trendlinesOn = true;
    async Task OnButtonClicked()
    {
        trendlinesOn = !trendlinesOn;

        await HandleRedraw();
    }

    string DayGroupingText(int dayGrouping)
    {
        switch (dayGrouping)
        {
            case 5:
                return "Groups of 5 days (73 groups)";
            case 7:
                return "Groups of 7 days (52 groups)";
            case 13: 
                return "Groups of 13 days (28 groups)";
            case 14:
                return "Groups of 14 days (26 groups)";
            case 26:
                return "Groups of 26 days (14 groups)";
            case 28:
                return "Groups of 28 days (13 groups)";
            case 73:
                return "Groups of 73 days (5 groups)";
            case 91:
                return "Groups of 91 days (4 groups)";
            case 182:
                return "Groups of 182 days (2 groups)";
        }
        throw new NotImplementedException(dayGrouping.ToString());
    }

    Stream GetFileStream()
    {
        var resolution = SelectedChartType == ChartType.Line ? "Yearly average" : "Yearly values relative to average";

        var data = new List<string> { $"{SelectedLocation.Name},{SelectedLocation.Coordinates.ToString(true)}" };

        data.Add($"{resolution},{ChartStartYear}-{ChartEndYear},Averaging method: {DayGroupingText(SelectedDayGrouping).ToLower()} with a threshold of {SelectedDayGroupThreshold},average requiring all groupings for a full data set - otherwise record null");
        data.Add(string.Empty);

        var header = "Year," + string.Join(",", CorrelatedDataSets.Select(x => $"{x.DataType} {x.DataAdjustment}"));
        data.Add(header);

        foreach (var label in GetLabels())
        {
            var dataRow = label + ",";
            foreach (var dataSet in CorrelatedDataSets)
            {
                var dataRecord = dataSet.DataRecords.Single(x => x.Year == short.Parse(label));
                dataRow += (dataRecord.Value == null ? string.Empty : MathF.Round((float)dataRecord.Value, 2).ToString("0.00")) + ",";
            }
            dataRow = dataRow.TrimEnd(',');
            data.Add(dataRow);
        }

        var bytes = data.SelectMany(s => System.Text.Encoding.UTF8.GetBytes(s + Environment.NewLine)).ToArray();
        var fileStream = new MemoryStream(bytes);

        return fileStream;
    }

    @inject IJSRuntime JS
    private async Task OnDownloadDataClicked()
    {
        var fileStream = GetFileStream();
        var fileName = $"{SelectedLocation.Name} {ChartStartYear}-{ChartEndYear}.csv";

        using var streamRef = new DotNetStreamReference(stream: fileStream);

        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    async Task OnNearbyLocationClicked(Guid guid)
    {
        await SelectedLocationChanged(guid);
    }


    float SelectedDayGroupThreshold { get; set; } = .7f;
    string DayGroupThresholdText { get; set; }
    short SelectedDayGrouping { get; set; } = 14;
    short SelectingDayGrouping { get; set; }

    async Task OnSelectingDayGroupingChanged(short value)
    {
        SelectingDayGrouping = value;
    }

    async Task OnDayGroupThresholdTextChanged(string value)
    {
        DayGroupThresholdText = value;
    }

    async Task ApplyYearlyAverageParameters()
    {
        SelectedDayGroupThreshold = float.Parse(DayGroupThresholdText) / 100;
        SelectedDayGrouping = SelectingDayGrouping == 0 ? SelectedDayGrouping : SelectingDayGrouping;
        await BuildDataSets();
    }

    private MapContainer mapContainer;

    private async Task OnOverviewShowHide(bool isOverviewVisible)
    {
        await JS.InvokeVoidAsync("showOrHideMap", isOverviewVisible);
    }


    private SelectLocation selectLocationModal;

    private Task ShowSelectLocationModal()
    {
        return selectLocationModal.Show();

    }
    private Task HideSelectLocationModal()
    {
        return selectLocationModal.Hide();
    }

    private Modal optionsModal;
    private Task ShowOptionsModal()
    {
        DayGroupThresholdText = (SelectedDayGroupThreshold * 100).ToString();
        return optionsModal.Show();

    }
    private Task HideOptionsModal()
    {
        return optionsModal.Hide();
    }

    Filter filter;

    async Task ShowFilterModal()
    {
        await filter.Show();
    }

    async Task HideFilterModal()
    {
        await filter.Hide();
    }

    /// <summary>
    /// The chart type applied to the chart control. This depends both on which chart
    /// type the user has selected and whether or not the "Difference" channel has been
    /// enabled (if the "Difference" channel is enabled, then the chart has to be placed
    /// in "Bar" mode, or else the Difference bars don't render).
    ///
    /// You might wonder why we don't just always leave the chart in "Bar" mode. We did,
    /// actually, but then we noticed that in "Bar" mode, there's a small misalignment
    /// between grid lines and the datapoints.
    /// </summary>
    ChartType InternalChartType { get; set; }

    /// <summary>
    /// The chart type selected by the user on the options page
    /// </summary>
    ChartType SelectedChartType { get; set; }
    async Task OnSelectedChartTypeValueChanged(ChartType value)
    {
        SelectedChartType = value;

        await UpdateInternalChartType();
    }

    async Task UpdateInternalChartType()
    {
        InternalChartType =
            SelectedChartType == ChartType.Bar || Difference || Rainfall
            ? ChartType.Bar
            : ChartType.Line;

        await BuildDataSets();
    }

    List<short> DatasetYears { get; set; }
    List<short> SelectedYears;

    async Task OnSelectedYearsChanged(List<short> values)
    {
        if (!SelectedYears.Any() && values.Count == 0)
        {
            SelectedResolution = DataResolution.Yearly;
            await InvokeAsync(StateHasChanged);
            await BuildDataSets();
            return;
        }

        var validValues = new List<short>();
        foreach (var value in values)
        {
            if (DatasetYears.Any(x => x == value))
            {
                validValues.Add(value);
            }
        }
        SelectedYears = validValues;

        if (SelectedResolution == DataResolution.Yearly)
        {
            SelectedResolution = DataResolution.Monthly;
        }

        await InvokeAsync(StateHasChanged);
        await BuildDataSets();
    }

    List<string> StationsWithData { get; set; }

    DataResolution SelectedResolution { get; set; }
    async Task OnSelectedResolutionChanged(DataResolution value)
    {
        SelectedResolution = value;
        if (SelectedResolution == DataResolution.Yearly)
        {
            SelectedYears = new List<short>();
        }
        await BuildDataSets();
    }

    int SelectedMovingAverageInterval;
    async Task OnSelectedPeriodChanged(int value)
    {
        SelectedMovingAverageInterval = value;
        await HandleRedraw();
    }

    bool SoloSma;
    async Task OnSoloSmaChanged(bool value)
    {
        SoloSma = value;
        await HandleRedraw();
    }

    bool Adjusted = true;
    async Task OnAdjustedChanged(bool value)
    {
        Adjusted = value;
        await HandleRedraw();
    }

    bool Unadjusted;
    async Task OnUnadjustedChanged(bool value)
    {
        Unadjusted = value;
        await HandleRedraw();
    }

    bool Difference = false;
    async Task OnDifferenceChanged(bool value)
    {
        Difference = value;
        await UpdateInternalChartType();
    }

    bool UnadjustedDisabled, AdjustedDisabled, DifferenceDisabled;

    List<DataType> SelectedDataTypes = new List<DataType>();
    List<DataAdjustment> SelectedDataAdjustments = new List<DataAdjustment>();

    bool Maximums = true;
    async Task OnMaximumsChanged(bool value)
    {
        Maximums = value;
        await BuildDataSets();
    }

    bool Minimums;
    async Task OnMinimumsChanged(bool value)
    {
        Minimums = value;
        await BuildDataSets();
    }

    bool Rainfall;
    async Task OnRainfallChanged(bool value)
    {
        Rainfall = value;
        await UpdateInternalChartType();
    }

    string SelectedStartYear { get; set; }
    string SelectedEndYear { get; set; }

    Guid SelectedLocationId { get; set; }
    Location SelectedLocation { get; set; }
    DataSetDefinition SelectedDataSetDefinition { get; set; }

    [Inject]
    public IDataService DataService { get; set; }

    List<DataSet> Datasets { get; set; }
    IEnumerable<DataSetDefinition> DataSetDefinitions;
    IEnumerable<Location> Locations;
    ColourServer colours = new ColourServer();

    protected override async Task OnInitializedAsync()
    {
        SelectedResolution = DataResolution.Yearly;
        if (DataService == null)
        {
            throw new NullReferenceException(nameof(DataService));
        }
        DataSetDefinitions = (await DataService.GetDataSetDefinitions()).ToList();
        Locations = (await DataService.GetLocations()).ToList();

        Datasets = new List<DataSet>();
        SelectedYears = new List<short>();

        var uri = NavManager.ToAbsoluteUri(NavManager.Uri);
        if (QueryHelpers.ParseQuery(uri.Query).TryGetValue("locationId", out var locationIdStringValues))
        {
            await SelectedLocationChanged(Guid.Parse(locationIdStringValues.ToString()));
        }
        else
        {
            await SelectedLocationChanged(Guid.Parse("aed87aa0-1d0c-44aa-8561-cde0fc936395"));
        }

        await base.OnInitializedAsync();
    }

    protected async Task BuildDataSets()
    {
        var dataExists = false;
        Datasets = new List<DataSet>();
        if (Datasets == null)
        {
            throw new NullReferenceException(nameof(Datasets));
        }

        var relativeToAverage = SelectedChartType == ChartType.Bar;
        var statisticalMethod = relativeToAverage ? StatisticalMethod.GroupByDayThenAverage_Relative : StatisticalMethod.GroupByDayThenAverage;

        SelectedDataTypes = new List<DataType>();
        if (Maximums)
        {
            SelectedDataTypes.Add(DataType.TempMax);
        }
        if (Minimums)
        {
            SelectedDataTypes.Add(DataType.TempMin);
        }
        if (Rainfall)
        {
            SelectedDataTypes.Add(DataType.Rainfall);
        }
        foreach (var dataType in SelectedDataTypes)
        {
            if (dataType == DataType.Rainfall)
            {
                var rainfall = (await DataService.GetDataSet(dataType, DataResolution.Yearly, DataAdjustment.Unadjusted, SelectedLocationId, statisticalMethod: StatisticalMethod.Sum)).ToList();
                Datasets.AddRange(rainfall);
            }
            else
            {
                var adjusted = (await DataService.GetDataSet(dataType, DataResolution.Yearly, DataAdjustment.Adjusted, SelectedLocationId, statisticalMethod: statisticalMethod, dayGrouping: SelectedDayGrouping, dayGroupingThreshold: SelectedDayGroupThreshold)).ToList();
                Datasets.AddRange(adjusted);

                var unadjusted = (await DataService.GetDataSet(dataType, DataResolution.Yearly, DataAdjustment.Unadjusted, SelectedLocationId, statisticalMethod: statisticalMethod, dayGrouping: SelectedDayGrouping, dayGroupingThreshold: SelectedDayGroupThreshold)).ToList();
                Datasets.AddRange(unadjusted);

                if (!DifferenceDisabled)
                {
                    var difference = GenerateDifferenceDataSet(unadjusted, adjusted);
                    Datasets.Add(difference);
                }

                var adjustedYears = adjusted.SingleOrDefault()?.Years;
                var unadjustedYears = unadjusted.SelectMany(x => x.Years).Distinct();
                DatasetYears = adjustedYears == null ? unadjustedYears.ToList()
                                                     : adjustedYears.Concat(unadjustedYears).Distinct().OrderBy(x => x).ToList();
            }
        }

        foreach (var selectedYear in SelectedYears)
        {
            foreach (var dataType in SelectedDataTypes)
            {
                var adjusted = (await DataService.GetDataSet(dataType, SelectedResolution, DataAdjustment.Adjusted, SelectedLocationId, statisticalMethod, selectedYear, dayGrouping: SelectedDayGrouping, dayGroupingThreshold: SelectedDayGroupThreshold)).ToList();
                Datasets.AddRange(adjusted);

                var unadjusted = (await DataService.GetDataSet(dataType, SelectedResolution, DataAdjustment.Unadjusted, SelectedLocationId, statisticalMethod, selectedYear, dayGrouping: SelectedDayGrouping, dayGroupingThreshold: SelectedDayGroupThreshold)).ToList();
                Datasets.AddRange(unadjusted);
            }
        }

        await mapContainer.ScrollToPoint(new LatLng(SelectedLocation.Coordinates.Latitude, SelectedLocation.Coordinates.Longitude));

        await HandleRedraw();
    }

    DataSet GenerateDifferenceDataSet(List<DataSet> unadjusted, List<DataSet> adjusted)
    {
        var difference = new DataSet
        {
            Resolution = DataResolution.Yearly,
            DataType = unadjusted.First().DataType,
            DataAdjustment = DataAdjustment.Difference,
        };
        unadjusted.ForEach(x =>
            {
                x.DataRecords.ForEach(y =>
                {
                    var adjustedTemp = adjusted.Single().DataRecords.SingleOrDefault(z => z.Year == y.Year);
                    difference.DataRecords.Add(new DataRecord
                    {
                        Year = y.Year,
                        Value = adjustedTemp == null ? null : adjustedTemp.Value - y.Value,
                    });
                });
            }
        );
        return difference;
    }

    Chart<float?> chart;
    ChartTrendline<float?> chartTrendline;

    async Task OnStartYearTextChanged(string text)
    {
        SelectedStartYear = text;
        await HandleRedraw();
    }

    async Task OnEndYearTextChanged(string text)
    {
        SelectedEndYear = text;
        
        await HandleRedraw();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await HandleRedraw();
        }
    }

    List<DataSet> CorrelatedDataSets = new List<DataSet>();
    short ChartStartYear, ChartEndYear;

    async Task HandleRedraw()
    {
        if (Datasets == null)
        {
            return;
        }

        colours = new ColourServer();

        var labels = new string[0];
        var unadjustedMaximums = new List<float?>();
        var unadjustedMinimums = new List<float?>();
        var adjustedMaximums = new List<float?>();
        var adjustedMinimums = new List<float?>();

        var title = string.Empty;
        var subtitle = string.Empty;

        await chart.Clear();

        CorrelatedDataSets = new List<DataSet>();
        Func<DataRecord, bool> timeConstraint = null;
        List<ChartTrendlineData> trendlines = null;

        if (SelectedResolution == DataResolution.Yearly)
        {
            var selectedDataSets =
                Datasets.Where(
                    x => 
                        x.Resolution == DataResolution.Yearly && 
                        (
                            (Adjusted && x.DataAdjustment == DataAdjustment.Adjusted) || 
                            (Unadjusted && x.DataAdjustment == DataAdjustment.Unadjusted) || 
                            (Difference && x.DataAdjustment == DataAdjustment.Difference) ||
                            (Rainfall && x.DataType == DataType.Rainfall)
                        )
                )
                .ToList();

            CorrelatedDataSets = CreateStandardisedDataSet(selectedDataSets);

            // Find the earliest and latest year across all datasets being plotted
            var superSetStartYear = CorrelatedDataSets.Min(x => x.DataRecords.Min(y => y.Year));
            var superSetEndYear = CorrelatedDataSets.Max(x => x.DataRecords.Max(y => y.Year));

            var userStartYear = string.IsNullOrEmpty(SelectedStartYear) ? null : (short?)short.Parse(SelectedStartYear);
            var userEndYear = string.IsNullOrEmpty(SelectedEndYear) ? null : (short?)short.Parse(SelectedEndYear);

            ChartStartYear = superSetStartYear;
            ChartEndYear = superSetEndYear;
            if (userStartYear != null)
            {
                if (userStartYear >= superSetStartYear && userStartYear <= superSetEndYear)
                {
                    ChartStartYear = userStartYear.Value;
                }
            }

            if (userEndYear != null)
            {
                if (userEndYear > superSetStartYear && userEndYear <= superSetEndYear)
                {
                    ChartEndYear = userEndYear.Value;
                }
            }

            title = SelectedLocation.Name;
            subtitle = 
                SelectedChartType == ChartType.Line
                ? $"Average Yearly Temperature ({ChartStartYear}-{ChartEndYear})"
                : $"Temperature Relative to Average ({ChartStartYear}-{ChartEndYear})";

            timeConstraint = x => x.Year >= ChartStartYear && x.Year <= ChartEndYear;

            Labels = GetLabels();
            await chart.AddLabels(Labels);

            trendlines = await AddDataSetsToGraph(CorrelatedDataSets, timeConstraint);
        }
        else
        {
            var selectedDataSets = Datasets.Where(x => x.Resolution == SelectedResolution
                && ((Adjusted && x.DataAdjustment == DataAdjustment.Adjusted) || (Unadjusted && x.DataAdjustment == DataAdjustment.Unadjusted))
                && SelectedYears.Contains(x.Year.Value)).ToList();

            foreach (var dataSet in selectedDataSets)
            {
                CorrelatedDataSets.Add(dataSet);
            }

            title = $"{SelectedLocation.Name}";
            subtitle = $"{string.Join(", ", SelectedYears)} {SelectedResolution} Chart";        

            var calendar = new GregorianCalendar();

            if (SelectedYears.Any())
            {
                var selectedYear = SelectedYears.FirstOrDefault(x => calendar.IsLeapYear(x));

                if (selectedYear == 0)
                {
                    selectedYear = SelectedYears.First();
                }

                switch (SelectedResolution)
                {
                    case DataResolution.Daily:
                        {
                            var numberOfDays = calendar.GetDaysInYear(selectedYear);
                            labels = new string[numberOfDays];
                            var date = new DateOnly(selectedYear, 1, 1);
                            for (var i = 0; i < numberOfDays; i++)
                            {
                                labels[i] = date.ToString("dd/MM");
                                date = date.AddDays(1);
                            }
                            break;
                        }
                    case DataResolution.Weekly:
                        {
                            labels = new string[52];
                            for (var i = 0; i < 52; i++)
                            {
                                labels[i] = $"Week {i + 1}";
                            }
                            break;
                        }
                    case DataResolution.Monthly:
                        {
                            labels = new string[12];
                            for (var i = 0; i < 12; i++)
                            {
                                labels[i] = new DateTime(2010, i + 1, 1).ToString("MMMM", CultureInfo.InvariantCulture);
                            }
                            break;
                        }
                }
            }

            Labels = labels;
            await chart.AddLabels(Labels);

            for (var i = 0; i < SelectedYears.Count; i++)
            {

                var year = SelectedYears[i];
                if (!CorrelatedDataSets.Any(x => x.Year == year))
                {
                    continue;
                }
                timeConstraint = x => x.Year == year;
                await AddDataSetsToGraph(CorrelatedDataSets, timeConstraint, year.ToString(), year, (short)(96 * (i + 1)));
            }
        }

        var yLabel = SelectedChartType == ChartType.Line ? "Degrees Celsius (°C)" : "Degrees Celsius (°C) Relative to Average Temperature";
        var xLabel = GetXAxisLabel();

        object scales = new
            {
                X = new
                {
                    Title = new
                    {
                        Text = xLabel,
                        Display = true,
                        Color = "blue",
                    },
                },
                Rainfall = new
                {
                    Display = Rainfall,
                    Axis = "y",
                    Position = Maximums || Minimums ? "right" : "left",
                    Grid = new { DrawOnChartArea = false },
                    Title = new
                    {
                        Text = "Rainfall (mm)",
                        Display = true,
                        Color = "blue",
                    },
                },
                Temperature = new  
                { 
                    Display = Maximums || Minimums,
                    Axis = "y",
                    Position = "left",
                    Grid = new { DrawOnChartArea = false },
                    Title = new
                    {
                        Text = yLabel,
                        Display = true,
                        Color = "blue",
                    },
                }
            };
       

        object chartOptions = new
        {
            Responsive = true,
            MaintainAspectRatio = false,
            SpanGaps = false,
            Plugins = new
            {
                Title = new 
                { 
                    Text = title,
                    Display = true
                },
                Subtitle = new 
                { 
                    Text = subtitle,
                    Display = true
                },
            },
            Scales = scales
        };
        
        await chart.SetOptionsObject(chartOptions);

        await chart.Update();

        await chartTrendline.AddTrendLineOptions(trendlines);
    }

    string[] GetLabels()
    {
        var numberOfYears = ChartEndYear - ChartStartYear;
        var labels = new string[numberOfYears + 1];
        for (var i = 0; i <= numberOfYears; i++)
        {
            labels[i] = (ChartStartYear + i).ToString();
        }
        return labels;
    }

    string GetXAxisLabel()
    {
        switch (SelectedResolution)
        {
            case DataResolution.Yearly:
                return "Year";
            case DataResolution.Monthly:
                return "Month";
            case DataResolution.Weekly:
                return "Week";
            case DataResolution.Daily:
                return "Date (dd/mm)";
        }
        throw new Exception();
    }

    async Task<List<ChartTrendlineData>> AddDataSetsToGraph(List<DataSet> bufferedSelectedDataSet, Func<DataRecord, bool> timeConstraint, string? labelPrefix = null, short? year = null, short colourAdjust = 0)
    {
        var dataSetIndex = 0;
        if (!string.IsNullOrWhiteSpace(labelPrefix))
        {
            labelPrefix += " ";
        }
        var trendlines = new List<ChartTrendlineData>();
        if (Adjusted && Maximums)
        {
            var values = SelectTemperatureValues(bufferedSelectedDataSet, DataType.TempMax, DataAdjustment.Adjusted, timeConstraint, year);
            var label = labelPrefix + "Maximum Adjusted";
            var colour = ChartColor.FromHtmlColorCode(colours.GetNextColour(0));
            if (SelectedMovingAverageInterval == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, DataType.TempMax, colour));
                if (trendlinesOn)
                {
                    trendlines.Add(AddTrendline(dataSetIndex, colour));
                }
                dataSetIndex++;
            }
            if (SelectedMovingAverageInterval != 0)
            {
                await AddMovingAverage(label, values, DataType.TempMax);
                dataSetIndex++;
            }
        }
        if (Unadjusted && Maximums)
        {
            var values = SelectTemperatureValues(bufferedSelectedDataSet, DataType.TempMax, DataAdjustment.Unadjusted, timeConstraint, year);
            var label = labelPrefix + "Maximum Unadjusted";
            var colour = ChartColor.FromHtmlColorCode(colours.GetNextColour(1));
            if (SelectedMovingAverageInterval == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, DataType.TempMax, colour));
                if (trendlinesOn)
                {
                    trendlines.Add(AddTrendline(dataSetIndex, colour));
                }
                dataSetIndex++;
            }
            if (SelectedMovingAverageInterval != 0)
            {
                await AddMovingAverage(label, values, DataType.TempMax);
                dataSetIndex++;
            }
        }
        if (Difference && Maximums)
        {
            var values = SelectTemperatureValues(bufferedSelectedDataSet, DataType.TempMax, DataAdjustment.Difference, timeConstraint, year);
            var label = labelPrefix + "Maximum Difference";

            await chart.AddDataSet(GetChartDataset(label, values, DataType.TempMax, chartType: ChartType.Bar));
        }
        if (Difference && Minimums)
        {
            var values = SelectTemperatureValues(bufferedSelectedDataSet, DataType.TempMin, DataAdjustment.Difference, timeConstraint, year);
            var label = labelPrefix + "Minimum Difference";
            await chart.AddDataSet(GetChartDataset(label, values, DataType.TempMin, chartType: ChartType.Bar));
        }
        if (Adjusted && Minimums)
        {
            var values = SelectTemperatureValues(bufferedSelectedDataSet, DataType.TempMin, DataAdjustment.Adjusted, timeConstraint, year);
            var label = labelPrefix + "Minimum Adjusted";
            var colour = ChartColor.FromHtmlColorCode(colours.GetNextColour(2));
            if (SelectedMovingAverageInterval == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, DataType.TempMin, colour));
                if (trendlinesOn)
                {
                    trendlines.Add(AddTrendline(dataSetIndex, colour));
                }
                dataSetIndex++;
            }
            if (SelectedMovingAverageInterval != 0)
            {
                await AddMovingAverage(label, values, DataType.TempMin);
                dataSetIndex++;
            }
        }
        if (Unadjusted && Minimums)
        {
            var values =  SelectTemperatureValues(bufferedSelectedDataSet, DataType.TempMin, DataAdjustment.Unadjusted, timeConstraint, year);
            var label = labelPrefix + "Minimum Unadjusted";
            var colour = ChartColor.FromHtmlColorCode(colours.GetNextColour(3));
            if (SelectedMovingAverageInterval == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, DataType.TempMin, colour));
                if (trendlinesOn)
                {
                    trendlines.Add(AddTrendline(dataSetIndex, colour));
                }
                dataSetIndex++;
            }
            if (SelectedMovingAverageInterval != 0)
            {
                await AddMovingAverage(label, values, DataType.TempMin);
                dataSetIndex++;
            }
        }
        if (Rainfall)
        {
            var values =  SelectTemperatureValues(bufferedSelectedDataSet, DataType.Rainfall, DataAdjustment.Unadjusted, timeConstraint, year);
            var label = labelPrefix + "Rainfall";
            if (SelectedMovingAverageInterval == 0 || !SoloSma)
            {
                await chart.AddDataSet(GetChartDataset(label, values, DataType.Rainfall, chartType: ChartType.Bar, redPositive: false));
            }
            //await AddMovingAverage(label, values);
        }
        if (trendlines.Count == 1)
        {
            trendlines[0].Color = ChartColor.FromRgba(0, 0, 0, 1f);
        }
        return trendlines;
    }

    ChartTrendlineData AddTrendline(int datasetIndex, ChartColor colour)
    {
        
        return
            new ChartTrendlineData
                {
                    DatasetIndex = datasetIndex,
                    Width = 3,
                    Color = colour
                };
    }

    async Task AddMovingAverage(string label, List<float?> values, DataType dataType)
    {
        if (SelectedChartType == ChartType.Line && SelectedMovingAverageInterval != 0)
        {
            var simpleMovingAverages = SimpleMovingAverage.Calculate(SelectedMovingAverageInterval, values);
            label = $"{label} Moving Average @ {SelectedMovingAverageInterval} year interval";
            await chart.AddDataSet(GetLineChartDataset(label, simpleMovingAverages, ChartColor.FromHtmlColorCode(colours.GetNextColour()), dataType));
        }
    }

    List<float?> SelectTemperatureValues(List<DataSet> dataSet, DataType dataType, DataAdjustment dataAdjustment, Func<DataRecord, bool> timeConstraint, short? year = null)
    {
        var dataset = dataSet.Single(x => x.DataType == dataType && x.DataAdjustment == dataAdjustment && (year == null || x.Year == year.Value));

        var selectedValues = dataset
                            .DataRecords
                            .Where(timeConstraint)
                            .Select(x => x.Value)
                            .ToList();

        return selectedValues;
    }

    List<DataSet> CreateStandardisedDataSet(List<DataSet> dataSets)
    {
        var bufferedDataSets = new List<DataSet>();

        var superSetStartYear = dataSets.Min(x => x.DataRecords.Min(y => y.Year));
        var superSetEndYear = dataSets.Max(x => x.DataRecords.Max(y => y.Year));

        foreach (var dataSet in dataSets)
        {
            var temperatures = new List<DataRecord>();
            for (var year = superSetStartYear; year <= superSetEndYear; year++)
            {
                var record = dataSet.DataRecords.FirstOrDefault(x => x.Year == year);
                if (record == null)
                {
                    record = new DataRecord
                    {
                        Year = year,
                        Value = null,
                    };
                }
                temperatures.Add(record);
            }
            var bufferedDataSet = new DataSet { Location = dataSet.Location, DataType = dataSet.DataType, DataAdjustment = dataSet.DataAdjustment };
            bufferedDataSet.DataRecords = temperatures;
            bufferedDataSets.Add(bufferedDataSet);
        }
        return bufferedDataSets;
    }

    List<DataSet> CreateDailyBufferedDataSet(List<DataSet> dataSets)
    {
        var bufferedDataSets = new List<DataSet>();

        var startDate = new DateOnly(dataSets.Min(x => x.DataRecords.Min(y => y.Year)), 1, 1);
        foreach(var dataSet in dataSets)
        {
            var bufferedDataSet = new DataSet { Location = dataSet.Location, DataType = dataSet.DataType, DataAdjustment = dataSet.DataAdjustment };
            bufferedDataSets.Add(bufferedDataSet);

            var startYear = dataSet.DataRecords.Min(x => x.Date);
            var temperatures = new List<DataRecord>();
            //for (var i = superSetStartYear; i < startYear; i++)
            //{
            //    temperatures.Add(new DailyTemperatureRecord { Date = i });
            //}
            temperatures.AddRange(dataSet.DataRecords);
            bufferedDataSet.DataRecords = temperatures;
        }

        return bufferedDataSets;
    }

    ChartDataset<float?> GetChartDataset(string label, List<float?> values, DataType dataType, ChartColor? chartColour = null, ChartType? chartType = null, bool? absoluteValues = false, bool redPositive = true)
    {
        chartType = chartType ?? SelectedChartType;

        switch (chartType)
        {
            case ChartType.Line:
                return GetLineChartDataset(label, values, chartColour.Value, dataType);
            case ChartType.Bar:
                return GetBarChartDataset(label, values, absoluteValues, redPositive);
        }

        throw new NotImplementedException();
    }

    BarChartDataset<float?> GetBarChartDataset(string label, List<float?> values, bool? absoluteValues, bool redPositive = true)
    {
        var colour = Enso.GetBarChartColourSet(values, redPositive);

        return new BarChartDataset<float?>
                    {
                        Label = label,
                        Data = values.Select(x => absoluteValues.GetValueOrDefault() && x.HasValue ? MathF.Abs(x.Value) : x).ToList(),
                        BorderColor = colour,
                        BackgroundColor = colour,
                    };
    }

    LineChartDataset<float?> GetLineChartDataset(string label, List<float?> values, ChartColor chartColor, DataType dataType)
    {
        var count = values.Count;
        var colour = new List<string>();
        for (var i = 0; i < count; i++)
            colour.Add(chartColor);

        return new LineChartDataset<float?>
                    {
                        Label = label,
                        Data = values,
                        BorderColor = colour,
                        Fill = false,
                        PointRadius = 5,
                        BorderDash = new List<int> { },
                        Tension = 0.1f,
                        YAxisID = dataType == DataType.Rainfall ? "rainfall" : "temperature"
                    };
    }

    async Task SelectedLocationChanged(Guid newValue)
    {
        SelectedLocationId = newValue;
        SelectedLocation = Locations.Single(x => x.Id == SelectedLocationId);
        SelectedDataSetDefinition = DataSetDefinitions.Single(x => x.Id == SelectedLocation.DataSetId);

        if (SelectedDataSetDefinition.DataAdjustments.Count == 2)
        {
            UnadjustedDisabled = false;
            AdjustedDisabled = false;
            DifferenceDisabled = false;
        }
        else
        {
            Unadjusted = SelectedDataSetDefinition.DataAdjustments.Contains(DataAdjustment.Unadjusted);
            Adjusted = SelectedDataSetDefinition.DataAdjustments.Contains(DataAdjustment.Adjusted);
            UnadjustedDisabled = true;
            AdjustedDisabled = true;
            DifferenceDisabled = true;
        }

        base.StateHasChanged();
        await BuildDataSets();
    }

    string[] Labels = new string[1];

    async Task OnLineChartClicked(ChartMouseEventArgs e)
    {
        if (SelectedResolution != DataResolution.Yearly)
        {
            return;
        }

        var year = (short)(ChartStartYear + e.Index);

        SelectedYears = new List<short> { year };
        SelectedResolution = DataResolution.Monthly;

        await BuildDataSets();
    }
}

