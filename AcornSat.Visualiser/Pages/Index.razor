@page "/"
@page "/location/"
@page "/location/{locationId}"

@implements IDisposable

@inject NavigationManager NavManager
@inject IExporter Exporter

@using AcornSat.Core
@using AcornSat.Core.Model
@using AcornSat.Core.ViewModel
@using AcornSat.Visualiser.Services
@using AcornSat.Visualiser.UiModel
@using Blazorise
@using Blazorise.Components
@using Blazorise.Charts
@using Blazorise.Charts.Trendline
@using System.IO;
@using System.Globalization
@using static AcornSat.Core.Enums
@using Microsoft.AspNetCore.WebUtilities
@using System.Text
@using DPBlazorMapLibrary

<PageTitle>@GetPageTitle()</PageTitle>

<div class="location-and-chart-container">
    <div>
        <div class="map-space-reserver" id="mapContainerContainer">
            <MapContainer @ref="mapContainer"
                          Locations="@Locations"
                          OnLocationChange="@SelectedLocationChanged"></MapContainer>

        </div>
        <div class="location-info-container">
            @if (SelectedLocation != null)
            {
                <LocationInfo @ref="locationInfoComponent"
                          Location="@SelectedLocation"
                          DataSetDefinition="@SelectedDataSetDefinition"
                          RequestLocationChange="@ShowSelectLocationModal"
                          OnOverviewShowOrHide="@OnOverviewShowHide"></LocationInfo>
            }
        </div>
        <div style="clear: both;"></div>
    </div>

    <div class="chart-collapsible-parent">
        <Collapsible Title="Chart" InitiallyShown="true" AllowCollapse="false" ContentLayoutType="Collapsible.CollapserContentLayoutType.FlexboxColumns">
            <Content>
                <div class="chart-and-controls">
                    <div class="chart-series-list-wrapper">
                        <ChartSeriesListView ChartSeriesList="ChartSeriesList" OnSeriesChanged="@BuildDataSets"></ChartSeriesListView>
                    </div>

                    <div class="chart-wrapper">
                        <div class="minimum-height-enforcer-for-chart"></div>
                        <div class="chart">
                            <Chart @ref="chart" TItem="float?" Clicked="@OnLineChartClicked" Type="ChartType.Line">
                                <ChartTrendline @ref="chartTrendline" TItem="float?" />
                            </Chart>
                        </div>
                    </div>

                    <div class="chart-controls">
                        <a class="chart-control" @onclick="() => locationInfoComponent.ChangeLocationClicked(null)"><i class="fas fa-map"></i> Change Location</a>
                        <a class="chart-control" @onclick="ShowOptionsModal"><i class="fas fa-cog"></i> Chart options</a>
                        <a class="chart-control" @onclick="ShowFilterModal"><i class="fas fa-calendar"></i> Year filtering</a>

                        @if (SelectedResolution == DataResolution.Yearly)
                        {
                            <a class="chart-control" @onclick="OnDownloadDataClicked"><i class="fas fa-download"></i> Download data</a>
                        }

                        <a class="chart-control" @onclick="ShowAddDataSetModal"><i class="fas fa-plus"></i> Add data set</a>

                    </div>
                </div>
            </Content>
        </Collapsible>
    </div>

    <div style="flex-grow: 0">
        <Collapsible Title="Suggested charts" InitiallyShown="true" NoBottomMargin="true">
            <Content>
                <SuggestedCharts @ref="suggestedChartsComponent" DataSetDefinitions="@DataSetDefinitions" SelectedLocation="@SelectedLocation" OnChartPresetSelected="@OnChartPresetSelected" ExpandUpwards="true"></SuggestedCharts>
            </Content>
        </Collapsible>
    </div>
</div>




<SelectLocation @ref="selectLocationModal"
                Locations="@Locations"
                SelectedLocation="@SelectedLocation"
                OnLocationChange="@SelectedLocationChanged" />

<Modal @ref="addDataSetModal">
    <ModalContent>
        <ModalHeader Background="Background.Light">
            <ModalTitle>Add data set</ModalTitle>
            <CloseButton />
        </ModalHeader>
        <ModalBody>
            <DataSetBrowser DataSetDefinitions="@DataSetDefinitions" OnAddDataSet="@OnAddDataSet" CurrentLocation="@SelectedLocation"></DataSetBrowser>
        </ModalBody>
    </ModalContent>
</Modal>

<Modal @ref="optionsModal">
    <ModalContent>
        <ModalHeader Background="Background.Light">
            <ModalTitle>Options</ModalTitle>
            <CloseButton />
        </ModalHeader>
        <ModalBody>
            <Alert Color="Color.Danger" Visible="true">
                Day grouping<br />
                <Select TValue="short" SelectedValue="@SelectedDayGrouping" SelectedValueChanged="@OnSelectedDayGroupingChanged">
                    <SelectItem Value="5">@DayGroupingText(5)</SelectItem>
                    <SelectItem Value="7">@DayGroupingText(7)</SelectItem>
                    <SelectItem Value="13">@DayGroupingText(13)</SelectItem>
                    <SelectItem Value="14">@DayGroupingText(14)</SelectItem>
                    <SelectItem Value="26">@DayGroupingText(26)</SelectItem>
                    <SelectItem Value="28">@DayGroupingText(28)</SelectItem>
                    <SelectItem Value="73">@DayGroupingText(73)</SelectItem>
                    <SelectItem Value="91">@DayGroupingText(91)</SelectItem>
                    <SelectItem Value="182">@DayGroupingText(182)</SelectItem>
                </Select>
                Threshold required to form a valid group (% percentage)<br />
                <TextEdit Text="@DayGroupThresholdText" TextChanged="@OnDayGroupThresholdTextChanged" MaskType="MaskType.RegEx" EditMask="^[1-9][0-9]?$|^100$" MaxLength="3" />
                <Button Color="Color.Primary" Clicked="@ApplyYearlyAverageParameters">Apply</Button>
            </Alert>
        </ModalBody>
    </ModalContent>
</Modal>

<Filter @ref="filter"
        DatasetYears="@DatasetYears"
        SelectedYears="@SelectedYears"
        SelectedStartYear="@SelectedStartYear"
        SelectedEndYear="@SelectedEndYear"
        SelectedResolution="@SelectedResolution"
        MostRecentStartYear="@MostRecentStartYear"
        OnSelectedYearsChanged="@OnSelectedYearsChanged"
        OnSelectedResolutionChanged="@OnSelectedResolutionChanged"
        OnStartYearTextChanged="@OnStartYearTextChanged"
        OnEndYearTextChanged="@OnEndYearTextChanged"
        OnMostRecentStartYearChanged="@OnMostRecentStartYearChanged"></Filter>




@code {
    [Parameter]
    public string LocationId { get; set; }

    LocationInfo locationInfoComponent { get; set; }
    SuggestedCharts suggestedChartsComponent { get; set; }

    @inject IJSRuntime JSRuntime
    @inject ILogger<Index> Logger;

    string GetPageTitle()
    {
        var locationText = SelectedLocation == null ? "" : " - " + SelectedLocation.Name;

        string title = $"Climate explorer{locationText}";

        Logger.LogInformation("GetPageTitle() returning '" + title + "' NavigateTo");

        return title;
    }

    bool trendlinesOn = false;
    async Task OnTrendlinesButtonClicked()
    {
        trendlinesOn = !trendlinesOn;

        await HandleRedraw();
    }

    string DayGroupingText(int dayGrouping)
    {
        switch (dayGrouping)
        {
            case 5:
                return "Groups of 5 days (73 groups)";
            case 7:
                return "Groups of 7 days (52 groups)";
            case 13:
                return "Groups of 13 days (28 groups)";
            case 14:
                return "Groups of 14 days (26 groups)";
            case 26:
                return "Groups of 26 days (14 groups)";
            case 28:
                return "Groups of 28 days (13 groups)";
            case 73:
                return "Groups of 73 days (5 groups)";
            case 91:
                return "Groups of 91 days (4 groups)";
            case 182:
                return "Groups of 182 days (2 groups)";
        }
        throw new NotImplementedException(dayGrouping.ToString());
    }

    private async Task OnDownloadDataClicked()
    {
        var fileStream = Exporter.ExportChartData(ChartSeriesWithData, Locations, GetLabels(SelectedResolution, ChartStartYear, ChartEndYear));

        var locationNames = ChartSeriesWithData.Select(x => x.ChartSeries.LocationName).Where(x => x != null).Distinct().ToArray();

        var fileName = locationNames.Any() ? String.Join("-", locationNames) + "-" : "";

        fileName = $"Export-{fileName}{ChartStartYear}-{ChartEndYear}.csv";

        using var streamRef = new DotNetStreamReference(stream: fileStream);

        await JSRuntime.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    float SelectedDayGroupThreshold { get; set; } = .7f;
    string DayGroupThresholdText { get; set; }
    short SelectedDayGrouping { get; set; } = 14;
    short SelectingDayGrouping { get; set; }

    async Task OnSelectedDayGroupingChanged(short value)
    {
        SelectingDayGrouping = value;
    }

    async Task OnDayGroupThresholdTextChanged(string value)
    {
        DayGroupThresholdText = value;
    }

    async Task ApplyYearlyAverageParameters()
    {
        SelectedDayGroupThreshold = float.Parse(DayGroupThresholdText) / 100;
        SelectedDayGrouping = SelectingDayGrouping == 0 ? SelectedDayGrouping : SelectingDayGrouping;
        await BuildDataSets();
    }

    private MapContainer mapContainer;

    private async Task OnOverviewShowHide(bool isOverviewVisible)
    {
        await JSRuntime.InvokeVoidAsync("showOrHideMap", isOverviewVisible);
    }

    private SelectLocation selectLocationModal;

    private Task ShowSelectLocationModal()
    {
        return selectLocationModal.Show();
    }

    private Task HideSelectLocationModal()
    {
        return selectLocationModal.Hide();
    }


    Modal addDataSetModal;

    private Task ShowAddDataSetModal()
    {
        return addDataSetModal.Show();
    }

    private Task HideAddDataSetModal()
    {
        return addDataSetModal.Hide();
    }

    private Modal optionsModal;
    private Task ShowOptionsModal()
    {
        DayGroupThresholdText = (SelectedDayGroupThreshold * 100).ToString();
        return optionsModal.Show();
    }

    private Task HideOptionsModal()
    {
        return optionsModal.Hide();
    }

    Filter filter;

    async Task ShowFilterModal()
    {
        await filter.Show();
    }

    async Task HideFilterModal()
    {
        await filter.Hide();
    }

    /// <summary>
    /// The chart type applied to the chart control. If any series is in "Bar" mode, we switch
    /// the entire chart to Bar type to ensure it renders, at the cost of a small misalignment
    /// between grid lines and datapoints for any line series that are being displayed.
    /// Otherwise, we display in "Line" mode to avoid that cost.
    /// </summary>
    ChartType InternalChartType { get; set; }

    /// <summary>
    /// The chart type selected by the user on the options page
    /// </summary>
    ChartType SelectedChartType { get; set; }
    async Task OnSelectedChartTypeValueChanged(ChartType value)
    {
        SelectedChartType = value;

        await UpdateInternalChartType();
    }

    async Task UpdateInternalChartType()
    {
        _haveCalledResizeAtLeastOnce = false;

        await BuildDataSets();
    }

    public async Task OnChartPresetSelected(List<ChartSeriesDefinition> chartSeriesDefinitions)
    {
        SelectedResolution = DataResolution.Yearly;

        ChartSeriesList = chartSeriesDefinitions.ToList();

        await BuildDataSets();
    }

    async Task OnAddDataSet(DataSetLibraryEntry dle)
    {
        Logger.LogInformation("Adding dle " + dle.SourceDataSetId);

        var dsd = DataSetDefinitions.Single(x => x.Id == dle.SourceDataSetId);

        var md = dsd.MeasurementDefinitions.Single(x => x.DataType == dle.DataType && x.DataAdjustment == dle.DataAdjustment);

        ChartSeriesList =
            ChartSeriesList
            .Concat(
                new List<ChartSeriesDefinition>()
                {
                    new ChartSeriesDefinition()
                    {
                        LocationId = dle.LocationId,
                        LocationName = dle.LocationName,
                        Aggregation = md.DataType == DataType.Rainfall ? SeriesAggregationOptions.Sum : SeriesAggregationOptions.Mean,
                        DataResolution = DataResolution.Yearly,
                        DataSetDefinition = dsd,
                        MeasurementDefinition = md,
                        Smoothing = SeriesSmoothingOptions.None,
                        SmoothingWindow = 5,
                        Value = SeriesValueOptions.Value,
                        Year = null
                    }
                }
            )
            .ToList();

        await BuildDataSets();
    }

    List<short>? DatasetYears { get; set; }
    List<short>? SelectedYears;

    async Task OnSelectedYearsChanged(List<short> values)
    {
        if (!SelectedYears.Any() && values.Count == 0)
        {
            SelectedResolution = DataResolution.Yearly;
            await InvokeAsync(StateHasChanged);

            RebuildChartSeriesListToReflectSelectedYears();

            await BuildDataSets();
            return;
        }

        var validValues = new List<short>();
        foreach (var value in values)
        {
            if (DatasetYears.Any(x => x == value))
            {
                validValues.Add(value);
            }
        }
        SelectedYears = validValues;

        if (SelectedResolution == DataResolution.Yearly)
        {
            SelectedResolution = DataResolution.Monthly;
        }

        await InvokeAsync(StateHasChanged);
        RebuildChartSeriesListToReflectSelectedYears();

        await BuildDataSets();
    }

    List<string> StationsWithData { get; set; }

    DataResolution SelectedResolution { get; set; }
    async Task OnSelectedResolutionChanged(DataResolution value)
    {
        SelectedResolution = value;
        if (SelectedResolution == DataResolution.Yearly)
        {
            SelectedYears = new List<short>();
        }

        foreach (var csd in ChartSeriesList)
        {
            csd.DataResolution = value;
        }

        ChartSeriesList = EliminateDuplicatesFromChartSeriesList(ChartSeriesList);

        await BuildDataSets();
    }

    string SelectedStartYear { get; set; }
    string SelectedEndYear { get; set; }

    Guid SelectedLocationId { get; set; }
    Location SelectedLocation { get; set; }
    DataSetDefinitionViewModel SelectedDataSetDefinition { get; set; }

    [Inject]
    public IDataService DataService { get; set; }

    List<DataSet> Datasets { get; set; }
    IEnumerable<DataSetDefinitionViewModel> DataSetDefinitions;
    IEnumerable<Location> Locations;
    ColourServer colours = new ColourServer();
    
    Guid _componentInstanceId = Guid.NewGuid();

    bool MostRecentStartYear { get; set; } = true;

    public void Dispose()
    {
        Logger.LogInformation("Instance " + _componentInstanceId + " disposing");
        NavManager.LocationChanged -= HandleLocationChanged;
    }

    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("Instance " + _componentInstanceId + " OnInitializedAsync");

        NavManager.LocationChanged += HandleLocationChanged;

        SelectedResolution = DataResolution.Yearly;
        if (DataService == null)
        {
            throw new NullReferenceException(nameof(DataService));
        }
        DataSetDefinitions = (await DataService.GetDataSetDefinitions()).ToList();

        // A cheat: register some 'derived' measurement types. Could be done better.
        var acornSatDsd = DataSetDefinitions.Single(x => x.Id == Guid.Parse("b13afcaf-cdbc-4267-9def-9629c8066321"));

        acornSatDsd.MeasurementDefinitions
            .Add(
                new MeasurementDefinitionViewModel
                    {
                        DataAdjustment = DataAdjustment.Difference,
                        DataType = DataType.TempMax,
                        UnitOfMeasure = UnitOfMeasure.DegreesCelsius,
                        PreferredColour = 0
                    }
            );

        acornSatDsd.MeasurementDefinitions
            .Add(
                new MeasurementDefinitionViewModel
                    {
                        DataAdjustment = DataAdjustment.Difference,
                        DataType = DataType.TempMin,
                        UnitOfMeasure = UnitOfMeasure.DegreesCelsius,
                        PreferredColour = 0
                    }
            );

        Locations = (await DataService.GetLocations(includeNearbyLocations: true, includeWarmingMetrics: true)).ToList();

        Datasets = new List<DataSet>();
        SelectedYears = new List<short>();

        var datasetYears = new List<short>();
        for (short i = 1800; i <= (short)DateTime.Now.Year; i++)
        {
            datasetYears.Add(i);
        }
        DatasetYears = datasetYears;

        await base.OnInitializedAsync();
    }

    void HandleLocationChanged(object sender, LocationChangedEventArgs e)
    {
        Logger.LogInformation("Instance " + _componentInstanceId + " HandleLocationChanged: " + NavManager.Uri);

        // The URL changed. Update UI state to reflect what's in the URL.
        base.InvokeAsync(UpdateUiStateBasedOnQueryString);
    }

    async Task UpdateUiStateBasedOnQueryString()
    {
        var uri = NavManager.ToAbsoluteUri(NavManager.Uri);

        if (QueryHelpers.ParseQuery(uri.Query).TryGetValue("csd", out var csdSpecifier))
        {
            try
            {
                var csdList = ChartSeriesListSerializer.ParseChartSeriesDefinitionList(Logger, csdSpecifier, DataSetDefinitions, Locations);

                Logger.LogInformation("Setting ChartSeriesList to list with " + csdList.Count + " items");

                ChartSeriesList = csdList.ToList();

                await BuildDataSets();

                StateHasChanged();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex.ToString());
            }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        Logger.LogInformation("OnParametersSetAsync() " + NavManager.Uri + " (NavigateTo)");

        Logger.LogInformation("OnParametersSetAsync(): " + LocationId);

        bool setupDefaultChartSeries = LocationId == null && ChartSeriesList.Count == 0;

        if (LocationId == null)
        {
            // Not sure whether we're allowed to set parameters this way, but it's short-lived - we'll immediately navigate away after
            // preparing querystring
            LocationId = "aed87aa0-1d0c-44aa-8561-cde0fc936395";
        }

        Guid locationId = Guid.Parse(LocationId);

        if (setupDefaultChartSeries)
        {
            var location = Locations.Single(x => x.Id == locationId);
            var dsd = DataSetDefinitions.Single(x => x.Id == location.DataSetId);
            var mdTempMax = dsd.MeasurementDefinitions.Single(x => x.DataType == DataType.TempMax && x.DataAdjustment == DataAdjustment.Adjusted);
            var mdRainfall = dsd.MeasurementDefinitions.Single(x => x.DataType == DataType.Rainfall);

            ChartSeriesList.Add(
                new ChartSeriesDefinition()
                {
                    LocationId = location.Id,
                    LocationName = location.Name,
                    Aggregation = SeriesAggregationOptions.Mean,
                    DataResolution = DataResolution.Yearly,
                    DataSetDefinition = dsd,
                    MeasurementDefinition = mdTempMax,
                    Smoothing = SeriesSmoothingOptions.MovingAverage,
                    SmoothingWindow = 20,
                    Value = SeriesValueOptions.Value,
                    Year = null
                }
            );

            ChartSeriesList.Add(
                new ChartSeriesDefinition()
                {
                    LocationId = location.Id,
                    LocationName = location.Name,
                    Aggregation = SeriesAggregationOptions.Sum,
                    DataResolution = DataResolution.Yearly,
                    DataSetDefinition = dsd,
                    MeasurementDefinition = mdRainfall,
                    Smoothing = SeriesSmoothingOptions.MovingAverage,
                    SmoothingWindow = 20,
                    Value = SeriesValueOptions.Value,
                    Year = null
                }
            );
        }

        // Pick up parameters from querystring
        await UpdateUiStateBasedOnQueryString();

        await SelectedLocationChangedInternal(locationId);

        await base.OnParametersSetAsync();
    }

    List<ChartSeriesDefinition> ChartSeriesList { get; set; } = new List<ChartSeriesDefinition>();

    List<SeriesWithData> ChartSeriesWithData { get; set; }

    protected async Task BuildDataSets()
    {
        // This method is called whenever anything has occurred that may require the chart to
        // be re-rendered.
        //
        // Examples:
        //     - User navigates to /locations/{anything}?csd={anythingelse} page for the first time
        //     - User updates URL manually while already at /locations
        //     - User chooses a preset or otherwise updates ChartSeriesList
        //     - User changes another setting that influences chart rendering (e.g. year filtering)
        //
        // Some, but not all, of those changes/events are reflected directly in the URL (e.g. location is in the
        // URL, and CSDs are in the URL).
        //
        // Others currently are not, but probably should be (e.g. year filtering).
        //
        // Our strategy here is:
        //
        // This method has been called because something has happened that may require the chart to be
        // re-rendered. We calculate the URI reflecting the current UI state. If we're already at that
        // URI, then we conclude that one of the properties has changed that does NOT impact the URI,
        // so we just immediately re-render the chart. If we are NOT already at that URI, then we just
        // trigger navigation to that URI, and DO NOT RE-RENDER THE CHART YET. Instead, as part of that
        // navigation process, methods will trigger that will re render the chart based on what's in the
        // updated URI.
        //
        // This is all to avoid re-rendering the chart more than once (bad for performance) or, even worse,
        // re-rendering the chart on two different async call chains at the same time (bad for correctness -
        // this was leading to the same series being rendered more than once, and the year labels on the
        // X axis being added more than once).

        Logger.LogInformation("BuildDataSets running with following CSDS:");

        foreach (var csd in ChartSeriesList)
        {
            Logger.LogInformation("    " + csd.ToString());
        }

        // Recalculate the URL
        string chartSeriesUrlComponent = ChartSeriesListSerializer.BuildChartSeriesListUrlComponent(ChartSeriesList);

        string url = "/location/" + LocationId;

        if (chartSeriesUrlComponent.Length > 0) url += "?csd=" + chartSeriesUrlComponent;

        string currentUri = NavManager.Uri;
        string newUri = NavManager.ToAbsoluteUri(url).ToString();

        if (currentUri != newUri)
        {
            Logger.LogInformation("Because the URI reflecting current UI state is different to the URI we're currently at, triggering navigation. After navigation occurs, the UI state will update accordingly.");

            bool shouldJustReplaceCurrentUrlBecauseWeAreAddingInQueryStringParametersForCsds = currentUri.IndexOf("csd=") == -1;
            
            // Just let the navigation process trigger the UI updates
            NavigateTo(url, shouldJustReplaceCurrentUrlBecauseWeAreAddingInQueryStringParametersForCsds);
        }
        else
        {
            Logger.LogInformation("Not calling NavigationManager.NavigateTo().");

            // Fetch the data required to render the selected data series
            ChartSeriesWithData = await RetrieveDataSets(ChartSeriesList);
            Logger.LogInformation("Set ChartSeriesWithData after call to RetrieveDataSets(). ChartSeriesWithData now has " + ChartSeriesWithData.Count + " entries.");

            // Render the series
            await HandleRedraw();
        }

        if (SelectedLocation != null)
        {
            await mapContainer.ScrollToPoint(new LatLng(SelectedLocation.Coordinates.Latitude, SelectedLocation.Coordinates.Longitude));
        }

        Logger.LogInformation("BuildDataSets() leaving");
    }

    public void RebuildChartSeriesListToReflectSelectedYears()
    {
        var years = SelectedYears.Any() ? SelectedYears.Select(x => (short?)x).ToList() : new List<short?>() { null };

        List<ChartSeriesDefinition> newCsds = new List<ChartSeriesDefinition>();

        var uniqueChartSeriesList = ChartSeriesList.Distinct(new ChartSeriesDefinition.ChartSeriesDefinitionComparerWhichIgnoresYearAndIsLocked()).ToArray();

        foreach (var csd in uniqueChartSeriesList)
        {
            foreach (var year in years)
            {
                newCsds.Add(
                    new ChartSeriesDefinition()
                        {
                            Aggregation = csd.Aggregation,
                            DataResolution = year == null ? DataResolution.Yearly : DataResolution.Monthly,
                            DataSetDefinition = csd.DataSetDefinition,
                            DisplayStyle = csd.DisplayStyle,
                            IsLocked = csd.IsLocked,
                            LocationId = csd.LocationId,
                            LocationName = csd.LocationName,
                            MeasurementDefinition = csd.MeasurementDefinition,
                            ShowTrendline = csd.ShowTrendline,
                            Smoothing = csd.Smoothing,
                            SmoothingWindow = csd.SmoothingWindow,
                            Value = csd.Value,
                            Year = year
                        }
                );
            }
        }

        Logger.LogInformation("RebuildChartSeriesListToReflectSelectedYears() setting ChartSeriesList");
        ChartSeriesList = newCsds;
    }

    public SeriesDisplayStyle ChooseSeriesDisplayStyleForChartSeries(MeasurementDefinitionViewModel measurementDefinition)
    {
        if (measurementDefinition.DataType == DataType.Rainfall) return SeriesDisplayStyle.Bar;
        if (measurementDefinition.DataAdjustment == DataAdjustment.Difference) return SeriesDisplayStyle.Bar;

        return SeriesDisplayStyle.Line;
    }

    async Task<List<SeriesWithData>> RetrieveDataSets(List<ChartSeriesDefinition> chartSeriesList)
    {
        var datasetsToReturn = new List<SeriesWithData>();

        Logger.LogInformation("RetrieveDataSets: starting enumeration");

        foreach (var csd in chartSeriesList)
        {
            List<DataSet> datasets;

            switch (csd.MeasurementDefinition.DataType)
            {
                case DataType.TempMax:
                case DataType.TempMin:
                case DataType.Rainfall:
                case DataType.SolarRadiation:
                    datasets =
                        (await DataService.GetDataSet(
                            csd.MeasurementDefinition.DataType,
                            csd.DataResolution,
                            csd.MeasurementDefinition.DataAdjustment,
                            ChooseDataSetApiAggregationMethod(csd.Aggregation, csd.Value),
                            csd.LocationId,
                            csd.Year,

                            // Ideally, these would be stored at CSD level, but for now, leaving them global
                            dayGrouping: SelectedDayGrouping,
                            dayGroupingThreshold: SelectedDayGroupThreshold
                        ))
                        .ToList();

                    break;

                case DataType.CH4:
                case DataType.CO2:
                case DataType.IOD:
                case DataType.MEIv2:
                case DataType.N2O:
                case DataType.Nino34:
                case DataType.ONI:
                case DataType.SOI:
                    datasets =
                        (await DataService.GetDataSet(
                            csd.MeasurementDefinition.DataType,
                            csd.DataResolution,
                            csd.MeasurementDefinition.DataAdjustment,
                            ChooseDataSetApiAggregationMethod(csd.Aggregation, csd.Value))
                        )
                        .ToList();

                    break;

                default:
                    throw new NotImplementedException();
            }

            datasetsToReturn.AddRange(
                datasets
                .Select(x => new SeriesWithData() { ChartSeries = csd, SourceDataSets = datasets })
            );
        }

        Logger.LogInformation("RetrieveDataSets: completed enumeration");

        return datasetsToReturn;
    }

    AggregationMethod ChooseDataSetApiAggregationMethod(SeriesAggregationOptions sao, SeriesValueOptions svo)
    {
        switch (sao)
        {
            case SeriesAggregationOptions.Sum:
                return AggregationMethod.Sum;
            case SeriesAggregationOptions.Mean:
                switch (svo)
                {
                    case SeriesValueOptions.Value:
                        return AggregationMethod.GroupByDayThenAverage;
                    case SeriesValueOptions.Anomaly:
                        return AggregationMethod.GroupByDayThenAverage_Anomaly;
                    default:
                        throw new NotImplementedException($"SeriesValueOptions {svo}");
                }
            default:
                throw new NotImplementedException($"SeriesAggregationOptions {sao}");
        }
    }

    static SeriesAggregationOptions MapAggregationMethodToSeriesAggregationOptions(AggregationMethod m)
    {
        switch (m)
        {
            case AggregationMethod.GroupByDayThenAverage:
            case AggregationMethod.GroupByDayThenAverage_Anomaly:
                return SeriesAggregationOptions.Mean;
            case AggregationMethod.Sum:
                return SeriesAggregationOptions.Sum;
            default:
                throw new NotImplementedException($"AggregationMethod {m}");
        }
    }

    Chart<float?> chart;
    ChartTrendline<float?> chartTrendline;

    async Task OnStartYearTextChanged(string text)
    {
        SelectedStartYear = text;
        await HandleRedraw();
    }

    async Task OnEndYearTextChanged(string text)
    {
        SelectedEndYear = text;

        await HandleRedraw();
    }

    async Task OnMostRecentStartYearChanged(bool value)
    {
        MostRecentStartYear = value;

        await HandleRedraw();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await HandleRedraw();
        }
    }

    short ChartStartYear, ChartEndYear;

    static Tuple<short, short> CalculateChartStartAndEndYear(
        List<SeriesWithData> chartSeriesWithData,
        string selectedStartYear,
        string selectedEndYear
    )
    {
        // Find the first and last year we have data for
        var superSetStartYear = chartSeriesWithData.SelectMany(x => x.ProcessedDataSets).SelectMany(x => x.DataRecords).Min(y => y.Year);
        var superSetEndYear = chartSeriesWithData.SelectMany(x => x.ProcessedDataSets).SelectMany(x => x.DataRecords).Max(y => y.Year);

        // Parse the start and end years, if any, specified by the user
        var userStartYear = string.IsNullOrEmpty(selectedStartYear) ? null : (short?)short.Parse(selectedStartYear);
        var userEndYear = string.IsNullOrEmpty(selectedEndYear) ? null : (short?)short.Parse(selectedEndYear);

        // Calculate chart start and end year
        var chartStartYear =
            // If the user specified a year in the range of available data, use it, otherwise, use the first available year
            userStartYear != null && userStartYear >= superSetStartYear && userStartYear <= superSetEndYear
            ? userStartYear.Value
            : superSetStartYear;

        var chartEndYear =
            // If the user specified a year in the range of available data (not including the first available year) use it,
            // otherwise, use the last available year
            userEndYear != null && userEndYear > superSetStartYear && userEndYear <= superSetEndYear
            ? userEndYear.Value
            : superSetEndYear;

        return new Tuple<short, short>(chartStartYear, chartEndYear);
    }

    async Task HandleRedraw()
    {
        Guid g = Guid.NewGuid();

        Logger.LogInformation("HandleRedraw " + g);

        await chart.Clear();

        // This can happen at startup, or if the user switches off all data series
        if (ChartSeriesWithData == null || ChartSeriesWithData.Count == 0)
        {
            return;
        }

        // We used to choose set ChartType to Bar if the user's selected chart type was bar or difference or rainfall,
        // and line otherwise.
        //
        // Since v2, we now set ChartType to Bar if any series is of type Bar, and Line otherwise.
        var newInternalChartType =
            ChartSeriesWithData.Any(x => x.ChartSeries.DisplayStyle == SeriesDisplayStyle.Bar)
            ? ChartType.Bar
            : ChartType.Line;

        if (newInternalChartType != InternalChartType)
        {
            InternalChartType = newInternalChartType;

            await chart.ChangeType(newInternalChartType);
        }

        colours = new ColourServer();

        var labels = new string[0];

        var title = string.Empty;
        var subtitle = string.Empty;

        List<ChartTrendlineData> trendlines = null;

        var locationNames = ChartSeriesWithData.Select(x => x.ChartSeries.LocationName).Where(x => x != null).Distinct().ToArray();

        title = ChartSeriesWithData.Count > 1 ? String.Join(", ", locationNames) : ChartSeriesWithData.Single().ChartSeries.FriendlyTitle;

        if (SelectedResolution == DataResolution.Yearly)
        {
            // Data sets sometimes have internal gaps in data (i.e. years which have no data even though earlier
            // and later years have data). Additionally, they may have external gaps in data if the overall period
            // to be charted goes beyond the range of the available data in one particular data set.
            //
            // To ensure these gaps are handled correctly in the plotted chart, we build a new dataset that includes
            // records for each missing year. Value is set to null for those records.
            BuildProcessedDataSetsForYearlyView(ChartSeriesWithData, MostRecentStartYear);

            (ChartStartYear, ChartEndYear) = CalculateChartStartAndEndYear(ChartSeriesWithData, SelectedStartYear, SelectedEndYear);

            // Now, we cut down the processed datasets to just the years that we intend to display on the chart.
            foreach (var cswd in ChartSeriesWithData)
            {
                Logger.LogInformation("HandleRedraw " + g + " - cswd");

                foreach (var psd in cswd.ProcessedDataSets)
                {
                    Logger.LogInformation("HandleRedraw " + g + " -   psd");

                    psd.DataRecords = psd.DataRecords.Where(x => x.Year >= ChartStartYear && x.Year <= ChartEndYear).ToList();
                }
            }

            subtitle = $"({ChartStartYear}-{ChartEndYear})";

            Labels = GetLabels(SelectedResolution, ChartStartYear, ChartEndYear);

            trendlines = await AddDataSetsToGraph();
        }
        else
        {
            foreach (var cswd in ChartSeriesWithData)
            {
                // TODO: Is this shared reference okay? Or should we be cloning?
                cswd.ProcessedDataSets = cswd.SourceDataSets.ToList();
            }

            subtitle = $"{string.Join(", ", SelectedYears)} {SelectedResolution} Chart";

            var calendar = new GregorianCalendar();

            if (SelectedYears.Any())
            {
                // Build a list of x axis labels. Because we may have multiple years selected, and leap years
                // have a different number of days to non-leap years, we prefer to use a leap year when preparing
                // the list of x axis labels, if one is present in the user's list of selected years.
                var selectedYear = SelectedYears.FirstOrDefault(x => calendar.IsLeapYear(x));

                if (selectedYear == 0)
                {
                    selectedYear = SelectedYears.First();
                }

                labels = GetLabels(SelectedResolution, selectedYear: selectedYear);
                Labels = labels;

                await AddDataSetsToGraph();
            }
        }

        await chart.AddLabels(Labels);

        var xLabel = GetXAxisLabel();

        object scales = new
        {
            X = new
            {
                Title = new
                {
                    Text = xLabel,
                    Display = true,
                    Color = "blue",
                },
            },
            EnsoIndex = new
            {
                Display = ChartSeriesList.Any(x => x.MeasurementDefinition.UnitOfMeasure == UnitOfMeasure.EnsoIndex),
                Axis = "y",
                Position = "right",
                Grid = new { DrawOnChartArea = false },
                Title = new
                {
                    Text = UnitOfMeasureLabel(UnitOfMeasure.EnsoIndex),
                    Display = true,
                    Color = "blue",
                },
            },
            Millimetres = new
            {
                Display = ChartSeriesList.Any(x => x.MeasurementDefinition.UnitOfMeasure == UnitOfMeasure.Millimetres),
                Axis = "y",
                Position = "right",
                Grid = new { DrawOnChartArea = false },
                Title = new
                {
                    Text = UnitOfMeasureLabel(UnitOfMeasure.Millimetres),
                    Display = true,
                    Color = "blue",
                },
            },
            DegreesCelsius = new
            {
                Display = ChartSeriesList.Any(x => x.MeasurementDefinition.UnitOfMeasure == UnitOfMeasure.DegreesCelsius || x.MeasurementDefinition.UnitOfMeasure == UnitOfMeasure.DegreesCelsiusAnomaly),
                Axis = "y",
                Position = "left",
                Grid = new { DrawOnChartArea = false },
                Title = new
                {
                    Text = SelectedChartType == ChartType.Line ? UnitOfMeasureLabel(UnitOfMeasure.DegreesCelsius) : UnitOfMeasureLabel(UnitOfMeasure.DegreesCelsiusAnomaly),
                    Display = true,
                    Color = "blue",
                },
            },
            PartsPerMillion = new
            {
                Display = ChartSeriesList.Any(x => x.MeasurementDefinition.UnitOfMeasure == UnitOfMeasure.PartsPerMillion),
                Axis = "y",
                Position = "right",
                Grid = new { DrawOnChartArea = false },
                Title = new
                {
                    Text = UnitOfMeasureLabel(UnitOfMeasure.PartsPerMillion),
                    Display = true,
                    Color = "blue",
                },
            },
            PartsPerBillion = new
            {
                Display = ChartSeriesList.Any(x => x.MeasurementDefinition.UnitOfMeasure == UnitOfMeasure.PartsPerBillion),
                Axis = "y",
                Position = "right",
                Grid = new { DrawOnChartArea = false },
                Title = new
                {
                    Text = UnitOfMeasureLabel(UnitOfMeasure.PartsPerBillion),
                    Display = true,
                    Color = "blue",
                },
            },
            MegajoulesPerSquareMetre = new
            {
                Display = ChartSeriesList.Any(x => x.MeasurementDefinition.UnitOfMeasure == UnitOfMeasure.MegajoulesPerSquareMetre),
                Axis = "y",
                Position = "right",
                Grid = new { DrawOnChartArea = false },
                Title = new
                {
                    Text = UnitOfMeasureLabel(UnitOfMeasure.MegajoulesPerSquareMetre),
                    Display = true,
                    Color = "blue",
                },
            },
        };

        object chartOptions = new
        {
            Responsive = true,
            MaintainAspectRatio = false,
            SpanGaps = false,
            Plugins = new
            {
                Title = new
                {
                    Text = title,
                    Display = true
                },
                Subtitle = new
                {
                    Text = subtitle,
                    Display = true
                },
            },
            Scales = scales
        };

        await chart.SetOptionsObject(chartOptions);

        await chart.Update();

        if (trendlines != null)
        {
            await chartTrendline.AddTrendLineOptions(trendlines);
        }

        // The below line is required to get the chart.js component to honour the styling applied on the parent div
        // If you don't call resize, the chart will apply the styling only after you resize the window,
        // but it does not apply the style on the initial load of the page.
        // See https://www.chartjs.org/docs/latest/configuration/responsive.html for more information
        if (!_haveCalledResizeAtLeastOnce)
        {
            await chart.Resize();
            _haveCalledResizeAtLeastOnce = true;
        }
    }

    bool _haveCalledResizeAtLeastOnce = false;

    string[] GetLabels(DataResolution dataResolution, short? chartStartYear = null, short? chartEndYear = null, short? selectedYear = null)
    {
        switch (dataResolution)
        {
            case DataResolution.Yearly:
                {
                    var numberOfYears = chartEndYear.Value - chartStartYear.Value;
                    var labels = new string[numberOfYears + 1];
                    for (var i = 0; i <= numberOfYears; i++)
                    {
                        labels[i] = (chartStartYear.Value + i).ToString();
                    }
                    return labels;
                }
            case DataResolution.Daily:
                {
                    var calendar = new GregorianCalendar();
                    var numberOfDays = calendar.GetDaysInYear(selectedYear.Value);
                    var labels = new string[numberOfDays];
                    var date = new DateOnly(selectedYear.Value, 1, 1);
                    for (var i = 0; i < numberOfDays; i++)
                    {
                        labels[i] = date.ToString("dd/MM");
                        date = date.AddDays(1);
                    }
                    return labels;
                }
            case DataResolution.Weekly:
                {
                    var labels = new string[52];
                    for (var i = 0; i < 52; i++)
                    {
                        labels[i] = $"Week {i + 1}";
                    }
                    return labels;
                }
            case DataResolution.Monthly:
                {
                    var labels = new string[12];
                    for (var i = 0; i < 12; i++)
                    {
                        labels[i] = new DateTime(2010, i + 1, 1).ToString("MMMM", CultureInfo.InvariantCulture);
                    }
                    return labels;
                }
        }
        throw new NotImplementedException();
    }

    string GetXAxisLabel()
    {
        switch (SelectedResolution)
        {
            case DataResolution.Yearly:
                return "Year";
            case DataResolution.Monthly:
                return "Month";
            case DataResolution.Weekly:
                return "Week";
            case DataResolution.Daily:
                return "Date (dd/mm)";
        }
        throw new Exception();
    }

    async Task<List<ChartTrendlineData>> AddDataSetsToGraph()
    {
        var dataSetIndex = 0;

        colours = new ColourServer();

        var trendlines = new List<ChartTrendlineData>();

        foreach (var chartSeries in ChartSeriesWithData)
        {
            foreach (var dataSet in chartSeries.ProcessedDataSets)
            {
                await AddDataSetToChart(
                    chartSeries,
                    dataSet,
                    dataSet.DataAdjustment,
                    $"{chartSeries.ChartSeries.FriendlyTitle} {UnitOfMeasureLabelShort(dataSet.MeasurementDefinition.UnitOfMeasure)}",
                    dataSet.MeasurementDefinition.PreferredColour);

                if (chartSeries.ChartSeries.ShowTrendline)
                {
                    trendlines.Add(CreateTrendline(dataSetIndex, ChartColor.FromHtmlColorCode(colours.GetNextColour(dataSet.MeasurementDefinition.PreferredColour))));
                }

                dataSetIndex++;
            }
        }

        return trendlines;
    }

    async Task AddDataSetToChart(
        SeriesWithData chartSeries,
        DataSet dataSet,
        DataAdjustment? dataAdjustment,
        string label,
        int preferredColour,
        bool absoluteValues = false,
        bool redPositive = true)
    {
        var values =
            dataSet.DataRecords
            .Select(x => x.Value)
            .ToList();

        Logger.LogInformation($"AddDataSetToChart: values has {values.Count} entries, of which {values.Count(x => x != null)} are not null");

        string htmlColourCode = colours.GetNextColour(preferredColour);

        var colour = ChartColor.FromHtmlColorCode(htmlColourCode);

        chartSeries.ChartSeries.Colour = htmlColourCode;

        var chartType =
            chartSeries.ChartSeries.DisplayStyle == SeriesDisplayStyle.Line
            ? ChartType.Line
            : ChartType.Bar;

        await chart.AddDataSet(GetChartDataset(label, values, dataSet.MeasurementDefinition.UnitOfMeasure, chartType, colour, absoluteValues, redPositive));
    }

    ChartTrendlineData CreateTrendline(int datasetIndex, ChartColor colour)
    {
        return
            new ChartTrendlineData
                {
                    DatasetIndex = datasetIndex,
                    Width = 3,
                    Color = colour
                };
    }

    ChartDataset<float?> GetMovingAverageChartDataset(int smoothingWindow, string label, List<float?> values, UnitOfMeasure unitOfMeasure, ChartType chartType, ChartColor colour)
    {
        var simpleMovingAverages = SimpleMovingAverage.Calculate(smoothingWindow, values);

        switch (chartType)
        {
            case ChartType.Line:
                return GetLineChartDataset(label, simpleMovingAverages, colour, unitOfMeasure);
            case ChartType.Bar:
                return GetBarChartDataset(label, simpleMovingAverages, unitOfMeasure, false);
            default:
                throw new NotImplementedException($"ChartType {chartType}");
        }
    }

    void BuildProcessedDataSetsForYearlyView(List<SeriesWithData> chartSeriesWithData, bool mostRecentStartYear = true)
    {
        // If we're doing smoothing via the moving average, precalculate these data and add them to PreProcessedDataSets.
        // We do this because the SimpleMovingAverage calculate function will remove some years from the start of the data set.
        // It removes these years because it doesn't have a good enough average to present it to the user.
        // Therefore, we need to calculate the smoothing before we calculate the start year - the basis for labelling the chart
        // If we're not calculating a moving average, PreProcessedDataSets = SourceDataSets
        foreach (var cs in chartSeriesWithData)
        {
            if (cs.ChartSeries.Smoothing == SeriesSmoothingOptions.MovingAverage)
            {
                cs.PreProcessedDataSets = cs.SourceDataSets
                        .Select(
                            x =>
                                new DataSet
                                    {
                                        Location = x.Location,
                                        MeasurementDefinition = x.MeasurementDefinition,
                                        DataRecords = SimpleMovingAverage.Calculate(cs.ChartSeries.SmoothingWindow, x.DataRecords)
                                    }
                        )
                        .ToList();
            }
            else
            {
                cs.PreProcessedDataSets = cs.SourceDataSets;
            }
        }

        // Calculate first and last year which we have a data record for, across all data sets underpinning all chart series
        var allDataSets = chartSeriesWithData.SelectMany(x => x.PreProcessedDataSets);
        var allDataRecords = allDataSets.SelectMany(x => x.DataRecords);

        var startYear = mostRecentStartYear
                                ? allDataSets.Max(x => x.StartYear.Value)
                                : allDataRecords.Min(y => y.Year);
        var latestYearAcrossAllDataSets = allDataRecords.Max(y => y.Year);

        foreach (var cs in chartSeriesWithData)
        {
            // Create new datasets, same as the source, but with any gap years filled with null records
            cs.ProcessedDataSets =
                cs.PreProcessedDataSets
                .Select(
                    x =>
                        new DataSet
                            {
                                Location = x.Location,
                                MeasurementDefinition = x.MeasurementDefinition,
                                DataRecords =
                                        Enumerable.Range(startYear, latestYearAcrossAllDataSets - startYear + 1)
                                        .Select(
                                            year =>
                                                // If there's a record in the source dataset, use it
                                                x.DataRecords.SingleOrDefault(z => z.Year == year)
                                                // Otherwise, create a null record
                                                ?? new DataRecord { Year = (short)year, Value = null }
                                        )
                                        .ToList()
                            }
                )
                .ToList();
        }
    }

    List<DataSet> CreateDailyBufferedDataSet(List<DataSet> dataSets)
    {
        var bufferedDataSets = new List<DataSet>();

        var startDate = new DateOnly(dataSets.Min(x => x.DataRecords.Min(y => y.Year)), 1, 1);
        foreach (var dataSet in dataSets)
        {
            var bufferedDataSet = new DataSet { Location = dataSet.Location, MeasurementDefinition = dataSet.MeasurementDefinition };
            bufferedDataSets.Add(bufferedDataSet);

            var startYear = dataSet.DataRecords.Min(x => x.Date);
            var temperatures = new List<DataRecord>();

            temperatures.AddRange(dataSet.DataRecords);
            bufferedDataSet.DataRecords = temperatures;
        }

        return bufferedDataSets;
    }

    ChartDataset<float?> GetChartDataset(string label, List<float?> values, UnitOfMeasure unitOfMeasure, ChartType chartType, ChartColor? chartColour = null, bool? absoluteValues = false, bool redPositive = true)
    {
        switch (chartType)
        {
            case ChartType.Line:
                if (!chartColour.HasValue)
                {
                    throw new NullReferenceException(nameof(chartColour));
                }
                return GetLineChartDataset(label, values, chartColour.Value, unitOfMeasure);
            case ChartType.Bar:
                return GetBarChartDataset(label, values, unitOfMeasure, absoluteValues, redPositive);
        }

        throw new NotImplementedException();
    }

    BarChartDataset<float?> GetBarChartDataset(string label, List<float?> values, UnitOfMeasure unitOfMeasure, bool? absoluteValues, bool redPositive = true)
    {
        var colour = Enso.GetBarChartColourSet(values, redPositive);

        return new BarChartDataset<float?>
            {
                Label = label,
                Data = values.Select(x => absoluteValues.GetValueOrDefault() && x.HasValue ? MathF.Abs(x.Value) : x).ToList(),
                BorderColor = colour,
                BackgroundColor = colour,
                YAxisID = unitOfMeasure.ToString().ToLowerFirstChar(),
            };
    }

    LineChartDataset<float?> GetLineChartDataset(string label, List<float?> values, ChartColor chartColor, UnitOfMeasure unitOfMeasure)
    {
        var count = values.Count;
        var colour = new List<string>();
        for (var i = 0; i < count; i++)
            colour.Add(chartColor);

        var lineChartDataset =
            new LineChartDataset<float?>
                {
                    Label = label,
                    Data = values,
                    BorderColor = colour,
                    Fill = false,
                    PointRadius = 5,
                    PointBorderColor = "#eee",
                    PointHoverBackgroundColor = colour,
                    BorderDash = new List<int> { },
                    Tension = 0.1f,
                    YAxisID = unitOfMeasure.ToString().ToLowerFirstChar(),
                };

        return lineChartDataset;
    }

    async Task SelectedLocationChanged(Guid locationId)
    {
        NavigateTo("/location/" + locationId.ToString());
    }

    public void NavigateTo(string uri, bool replace = false)
    {
        Logger.LogInformation("NavManager.NavigateTo(uri=" + uri + ", replace=" + replace + ")");
        NavManager.NavigateTo(uri, false, replace);
    }

    async Task SelectedLocationChangedInternal(Guid newValue)
    {
        Logger.LogInformation("SelectedLocationChangedInternal(): " + newValue);

        SelectedLocationId = newValue;
        SelectedLocation = Locations.Single(x => x.Id == SelectedLocationId);
        SelectedDataSetDefinition = DataSetDefinitions.Single(x => x.Id == SelectedLocation.DataSetId);

        List<ChartSeriesDefinition> additionalCsds = new List<ChartSeriesDefinition>();

        // Update data series to reflect new location
        foreach (var csd in ChartSeriesList)
        {
            if (!csd.IsLocked)
            {
                if (csd.LocationId != null)
                {
                    csd.LocationId = newValue;
                    csd.LocationName = SelectedLocation.Name;

                    // But: the new location may not have data of the requested type. Since this series is location-specific, and we
                    // determine the DSD for a location based just on the location, let's update the CSD accordingly
                    csd.DataSetDefinition = SelectedDataSetDefinition;

                    // Next, update the MeasurementDefinition. Look for a match on DataType and DataAdjustment
                    var oldMd = csd.MeasurementDefinition;

                    var candidateMds =
                        csd.DataSetDefinition.MeasurementDefinitions
                        .Where(x => x.DataType == oldMd.DataType && x.DataAdjustment == oldMd.DataAdjustment)
                        .ToArray();

                    switch (candidateMds.Length)
                    {
                        case 0:
                            // There was no exact match. It's possible that the new location has data of the requested type, but not the specified adjustment type.
                            // If so, try defaulting.
                            candidateMds = csd.DataSetDefinition.MeasurementDefinitions.Where(x => x.DataType == oldMd.DataType).ToArray();

                            if (candidateMds.Length == 1)
                            {
                                // If only one is available, just use it
                                csd.MeasurementDefinition = candidateMds.Single();
                            }
                            else
                            {
                                // Otherwise, use "Adjusted" if available
                                var adjustedMd = candidateMds.SingleOrDefault(x => x.DataAdjustment == DataAdjustment.Adjusted);

                                if (adjustedMd != null)
                                {
                                    csd.MeasurementDefinition = adjustedMd;
                                }
                            }

                            break;

                        case 1:
                            csd.MeasurementDefinition = candidateMds.Single();
                            break;

                        default:
                            // There were multiple matches. That's unexpected.
                            throw new Exception("Unexpected condition: after changing location, while updating ChartSeriesDefinitions, there were multiple compatible MeasurementDefinitions for one CSD.");
                    }
                }
            }
            else
            {
                // It's locked, so duplicate it & set the location on the duplicate to the new location
                var newDsd = DataSetDefinitions.Single(x => x.Id == SelectedLocation.DataSetId);
                var newMd = 
                    newDsd.MeasurementDefinitions
                    .SingleOrDefault(x => x.DataType == csd.MeasurementDefinition.DataType && x.DataAdjustment == csd.MeasurementDefinition.DataAdjustment);

                if (newMd == null)
                {
                    newMd = 
                        newDsd.MeasurementDefinitions
                        .SingleOrDefault(x => x.DataType == csd.MeasurementDefinition.DataType && x.DataAdjustment == null);
                }

                if (newMd != null)
                {
                    additionalCsds.Add(
                        new ChartSeriesDefinition()
                        {
                            Aggregation = csd.Aggregation,
                            DataResolution = csd.DataResolution,
                            DataSetDefinition = DataSetDefinitions.Single(x => x.Id == SelectedLocation.DataSetId),
                            DisplayStyle = csd.DisplayStyle,
                            IsLocked = false,
                            LocationId = newValue,
                            LocationName = SelectedLocation.Name,
                            MeasurementDefinition = newMd,
                            ShowTrendline = csd.ShowTrendline,
                            Smoothing = csd.Smoothing,
                            SmoothingWindow = csd.SmoothingWindow,
                            Value = csd.Value,
                            Year = csd.Year
                        }
                    );
                }
            }
        }

        Logger.LogInformation("Adding items to list inside SelectedLocationChangedInternal()");

        var draftList = ChartSeriesList.Concat(additionalCsds).ToList();

        ChartSeriesList = EliminateDuplicatesFromChartSeriesList(draftList);

        await BuildDataSets();
    }

    static List<ChartSeriesDefinition> EliminateDuplicatesFromChartSeriesList(List<ChartSeriesDefinition> csds)
    {
        return csds.Distinct(new ChartSeriesDefinition.ChartSeriesDefinitionComparer()).ToList();
    }

    string[] Labels = new string[1];

    async Task OnLineChartClicked(ChartMouseEventArgs e)
    {
        if (SelectedResolution != DataResolution.Yearly)
        {
            return;
        }

        var year = (short)(ChartStartYear + e.Index);

        SelectedYears = new List<short> { year };
        SelectedResolution = DataResolution.Monthly;

        RebuildChartSeriesListToReflectSelectedYears();

        await BuildDataSets();
    }
}