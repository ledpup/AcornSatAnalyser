@using Blazorise
@using Blazorise.LoadingIndicator
@using ClimateExplorer.Core
@using ClimateExplorer.Core.Model
@using ClimateExplorer.Core.ViewModel
@using ClimateExplorer.Visualiser.UiModel
@using ClimateExplorer.Core.Calculators
@using ClimateExplorer.Core.DataPreparation
@using static ClimateExplorer.Core.Enums

<LoadingIndicator @bind-Visible="@LocationLoadingIndicatorVisible" ZIndex="5">
    <Collapsible @ref="LocationCollapsible" Title="@Location?.Title" FullTitle="@Location?.FullTitle" OnShowOrHide="OverviewShowOrHideHandler" InitiallyShown="true" CollapserSize="Collapsible.CollapserSizes.ExtraLarge">
        <HeaderContent>
            <span class="chart-controls" style="margin-left: 32px;">
                <a class="chart-control" @onclick="() => ChangeLocationClicked(new EventArgs())"><i class="fas fa-map"></i> Change location</a>
                @if (LocationCollapsible!.ShowContent)
                {
                    <a class="chart-control" @onclick="() => ToggleRainfall()"><i class="@( rainfall ? "fas fa-check-square" : "fas fa-square" )"></i> Precipitation</a>
                }
            </span>
        </HeaderContent>
        <Content>
            <!-- The awful HTML comments between OverviewField elements below are to avoid generating whitespace between OverviewField elements, which was
            causing them to be misaligned. Probably better to use flex layout, but this works for now.
            -->
            <OverviewField Label="Location"><Value> <span><a href="@LocationMapUrl" target="_blank">@GeoLocationAsString</a></span></Value></OverviewField>
            <!--
            -->
            @if (WarmingIndexAsString != null && WarmingIndexAsString != "NA")
            {
                <OverviewField Label="Warming index" PopupText="@WarmingIndexDescription"><Value>@(WarmingIndexAsString == null ? "NA" : WarmingIndexAsString)</Value></OverviewField>
                <!--
                -->
                <OverviewField Label="Heating score" PopupText="@HeatingScoreDescription"><Value>@(Location!.HeatingScore == null ? "NA" : Location.HeatingScore)</Value></OverviewField>
            }
            <!--
            -->
            @if (RainfallIndexAsString != null && RainfallIndexAsString != "NA")
            {
                <OverviewField Label="Drying index"><Value>@(RainfallIndexAsString == null ? "NA" : RainfallIndexAsString)</Value></OverviewField>
            }
            <ClimateStripe UnitOfMeasure="UnitOfMeasure.DegreesCelsius" LocationName=@Location?.Name LocationMean=@TemperatureLocationMean DataRecords="@TemperatureAnomalyRecords" OnYearFilterChange=HandleOnYearFilterChange ShowInfo="true" />
            <WarmestYears DataRecords="@TemperatureAnomalyRecords" OnYearFilterChange=HandleOnYearFilterChange />
            @if (rainfall && RainfallLocationMean != null)
            {
                <ClimateStripe UnitOfMeasure="UnitOfMeasure.Millimetres" LocationName=@Location?.Name LocationMean=@RainfallLocationMean DataRecords="@RainfallAnomalyRecords" OnYearFilterChange=HandleOnRainfallYearFilterChange ShowInfo="false" />
                <DriestYears DataRecords="@RainfallAnomalyRecords" OnYearFilterChange=HandleOnRainfallYearFilterChange />
            }
        </Content>
    </Collapsible>
</LoadingIndicator>

@code {
    [Inject]
    public IDataService? DataService { get; set; }

    [Inject]
    ILogger<LocationInfo>? Logger { get; set; }

    [Parameter]
    public Location? Location { get; set; }

    [Parameter]
    public EventCallback RequestLocationChange { get; set; }

    [Parameter]
    public IEnumerable<DataSetDefinitionViewModel>? DataSetDefinitions { get; set; }

    [Parameter]
    public EventCallback<bool> OnOverviewShowOrHide { get; set; }

    [Parameter]
    public EventCallback<YearAndDataTypeFilter> OnYearFilterChange { get; set; }

    Collapsible? LocationCollapsible;

    Guid instanceId = Guid.NewGuid();

    string LocationMapUrl => Location == null ? "https://maps.google.com/" : $"https://maps.google.com/?q={Location.Coordinates.Latitude},{Location.Coordinates.Longitude}";
    string GeoLocationAsString => Location == null ? "Nowhere" : Location.Coordinates.ToString();

    public bool LocationLoadingIndicatorVisible { get; set; }
    bool rainfall { get; set; }

    List<YearAndValue>? TemperatureAnomalyRecords { get; set; }
    float? TemperatureLocationMean { get; set; }
    string? WarmingIndexDescription;
    string? WarmingIndexAsString;

    List<YearAndValue>? RainfallAnomalyRecords { get; set; }
    float? RainfallLocationMean { get; set; }
    string? RainfallIndexAsString;

    Guid? locationIdLastTimeOnParametersSetAsyncWasCalled;

    DataType? TemperatureDataType { get; set; }

    const string HeatingScoreDescription = @"<p>The heating score is a number between 0 and 9. It is calculated by ordering all warming indexes across the locations in the dataset and scoring in sets of 10 <a href=""https://en.wikipedia.org/wiki/Percentile"" target=""_blank"">percentiles</a>.</p>
<p>For example, the top ten 10% of warming indexes are scored as a 9, the bottom 10% are scored as 0.</p>
<p>Negative warming indexes are scored differently; they use the warming index, rounded to zero decimal places as the score. This is to highlight any location that has not warmed.</p>
<p>The score may be higher if:</p>
<ul><li>The location is inland. The ocean is warming more slowly compared with the land. Coastal locations are therefore likely to have warmed less than inland locations.</li>
<li>The station(s) has been operating for a long time. The effect of global warming is more obvious with a large dataset as temperatures in the past were cooler.</li></ul>";

    public void ChangeLocationClicked(EventArgs args)
    {
        RequestLocationChange.InvokeAsync();
    }

    void OverviewShowOrHideHandler(bool showOrHide)
    {
        OnOverviewShowOrHide.InvokeAsync(showOrHide);
    }

    protected override void OnInitialized()
    {
        LocationLoadingIndicatorVisible = true;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (Location == null)
        {
            return;
        }

        // We do manual change detection here because Blazor calls OnParametersSetAsync() repeatedly with the same input values.
        if (locationIdLastTimeOnParametersSetAsyncWasCalled == Location?.Id)
        {
            return;
        }
        LocationLoadingIndicatorVisible = true;
        locationIdLastTimeOnParametersSetAsyncWasCalled = Location?.Id;

        // Clear the previous values so we don't accidentally end-up reporting them
        RainfallLocationMean = null;
        RainfallAnomalyRecords = null;
        RainfallIndexAsString = null;

        // We can't do anything until we're supplied our tasty, tasty DataSetDefinitions
        if (DataSetDefinitions == null)
        {
            return;
        }

        await GetData(new List<DataSubstitute> { new DataSubstitute { DataType = DataType.Rainfall } }, ContainerAggregationFunctions.Sum);
        await GetData(DataSubstitute.StandardTemperatureDataMatches(), ContainerAggregationFunctions.Mean);

        LocationLoadingIndicatorVisible = false;

        await base.OnParametersSetAsync();
    }

    protected async Task GetData(List<DataSubstitute> dataSubstitutes, ContainerAggregationFunctions function)
    {
        var measurementForLocation =
            DataSetDefinitionViewModel.GetDataSetDefinitionAndMeasurement(
                DataSetDefinitions!,
                Location!.Id,
                dataSubstitutes,
                throwIfNoMatch: false);

        if (measurementForLocation != null)
        {
            // Retrieve TempMax anomaly
            var series =
                await DataService!.PostDataSet(
                    BinGranularities.ByYear,
                    function,
                    function,
                    function,
                    SeriesValueOptions.Anomaly,
                    new SeriesSpecification[]
                        {
                            new SeriesSpecification
                            {
                                DataAdjustment = measurementForLocation.MeasurementDefinition!.DataAdjustment,
                                DataSetDefinitionId = measurementForLocation.DataSetDefinition!.Id,
                                DataType = measurementForLocation.MeasurementDefinition.DataType,
                                LocationId = Location.Id
                            }
                        },
                    SeriesDerivationTypes.ReturnSingleSeries,
                    1.0f,
                    1.0f,
                    0.7f,
                    14,
                    SeriesTransformations.Identity);

            // Filter to records that have values
            var anomalyRecords =
                series.DataRecords
                .Where(x => x.Value != null)
                .Select(x => new YearAndValue(((YearBinIdentifier)BinIdentifier.Parse(x.BinId!)).Year, x.Value!.Value))
                .ToList();

            series =
                await DataService.PostDataSet(
                    BinGranularities.ByYear,
                    function,
                    function,
                    function,
                    SeriesValueOptions.Value,
                    new SeriesSpecification[]
                        {
                            new SeriesSpecification
                            {
                                DataAdjustment = measurementForLocation.MeasurementDefinition.DataAdjustment,
                                DataSetDefinitionId = measurementForLocation.DataSetDefinition.Id,
                                DataType = measurementForLocation.MeasurementDefinition.DataType,
                                LocationId = Location.Id
                            }
                        },
                    SeriesDerivationTypes.ReturnSingleSeries,
                    1.0f,
                    1.0f,
                    0.7f,
                    14,
                    SeriesTransformations.Identity);

            var index = IndexCalculator.CalculateIndex(series.DataRecords);

            if (dataSubstitutes.Any(x => x.DataType == DataType.Rainfall))
            {
                RainfallIndexAsString = GetRainfallIndexAsString(index, measurementForLocation.MeasurementDefinition.UnitOfMeasure);
                RainfallLocationMean = series.DataRecords.Average(x => x.Value);
                RainfallAnomalyRecords = anomalyRecords;
            }
            else if (dataSubstitutes.Any(x => x.DataType == DataType.TempMax))
            {
                TemperatureDataType = series.DataType;
                WarmingIndexAsString = GetWarmingIndexAsString(index, measurementForLocation.MeasurementDefinition.UnitOfMeasure);
                WarmingIndexDescription = GenerateWarmingIndexDescription(index, measurementForLocation.MeasurementDefinition.UnitOfMeasure);
                TemperatureLocationMean = series.DataRecords.Average(x => x.Value);
                TemperatureAnomalyRecords = anomalyRecords;
            }
            else
            {
                throw new NotImplementedException();
            }
        }

    }

    public async Task HandleOnYearFilterChange(short year)
    {
        var yearAndFilter = new YearAndDataTypeFilter(year) { DataType = TemperatureDataType };
        await OnYearFilterChange.InvokeAsync(yearAndFilter);
    }

    public async Task HandleOnRainfallYearFilterChange(short year)
    {
        var yearAndFilter = new YearAndDataTypeFilter(year) { DataType = DataType.Rainfall };
        await OnYearFilterChange.InvokeAsync(yearAndFilter);
    }

    static string GetRainfallIndexAsString(CalculatedIndex index, UnitOfMeasure unitOfMeasure)
    {
        if (index == null) return "NA";

        // it's how much drying, not how much rain
        var value = index.IndexValue * -1;

        return $"{(value >= 0 ? "+" : "")}{string.Format("{0:0.#}", MathF.Round(value, 0))}mm";
    }

    static string GetWarmingIndexAsString(CalculatedIndex warmingIndex, UnitOfMeasure unitOfMeasure)
    {
        if (warmingIndex == null) return "NA";

        return $"{(warmingIndex.IndexValue >= 0 ? "+" : "")}{string.Format("{0:0.#}", MathF.Round(warmingIndex.IndexValue, 1))}{(unitOfMeasure == UnitOfMeasure.DegreesCelsius ? "°C" : "mm")}";
    }

    string GenerateWarmingIndexDescription(CalculatedIndex warmingIndex, UnitOfMeasure unitOfMeasure)
    {
        if (Location == null)
        {
            return "NA";
        }

        string warmingIndexAsString = GetWarmingIndexAsString(warmingIndex, unitOfMeasure);

        if (warmingIndex == null)
        {
            return $@"<p>The warming index is the temperature difference between the average of the last 30 years of temperatures compared with the average of the first half of the dataset. 30 years was chosen to fit the convention of the <a href=""https://en.wikipedia.org/wiki/Climatological_normal"" target=""_blank"">climatological normal</a>. The first half of the datatset is used as a proxy for a natural baseline; it is expected to be less affected by anthropogenic warming.</p>
<p>Over the long-term, with no external influences, we'd expect the warming index to trend towards zero. A non-zero warming index may indicate an effect of climate change. A positive warming index may indicate global warming.</p>
<p>Note: The type of temperature measurement used as the basis for averages is the maximum temperature (usually a daily maximum). If the maximum temperature is not available, the mean temperature is used.</p>";
        }

        return
            String.Join(
                Environment.NewLine,
                $"<p>The warming index is the temperature difference between the average of the last 30 years of temperatures compared with the average of the first half ({warmingIndex.CountOfFirstHalf} years) of the dataset. 30 years was chosen to fit the convention of the <a href=\"https://en.wikipedia.org/wiki/Climatological_normal\" target=\"_blank\">climatological normal</a>. The first half of the datatset is used as a proxy for a natural baseline; it is expected to be less affected by anthropogenic warming.</p>",
                $"<p>{Location.Name}, between the years {warmingIndex.FirstYearInLast30Years}-{warmingIndex.LastYearInLast30Years}, had an average max temp of <strong>{string.Format("{0:0.##}", MathF.Round(warmingIndex.AverageOfLast30Years, 2))}°C</strong>.</p>",
                $"<p>{Location.Name}, between the years {warmingIndex.FirstYearInFirstHalf}-{warmingIndex.LastYearInFirstHalf}, had an average max temp of <strong>{string.Format("{0:0.##}", MathF.Round(warmingIndex.AverageOfFirstHalf, 2))}°C</strong>.</p>",
                $"<p>The difference is <strong>{warmingIndexAsString}</strong> (after rounding to 1 decimal place).</p>",
                $"<p>Over the long-term, with no external influences, we'd expect the warming index to trend towards zero. A non-zero warming index may indicate an effect of climate change. A positive warming index may indicate global warming.</p>",
                $"<p>Note: The type of temperature measurement used as the basis for averages is the maximum temperature (usually a daily maximum). If the maximum temperature is not available, the mean temperature is used.</p>"
            );
    }

    void ToggleRainfall()
    {
        rainfall = !rainfall;
    }
}
